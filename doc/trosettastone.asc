Tomb Raider Data Formats (TRosettaStone)
========================================
:doctype: book
:toc2:
:numbered:
:latexmath:
:icons:
:source-highlighter: pygments

Document Version 3.00 (150716)

*Tomb Raider I-V Data File Format*

(Including Tomb Raider `.PHD/.TUB`, Tomb Raider II-III `.TR2`, Tomb Raider IV `.TR4` and Tomb Raider Chronicles (V) `.TRC` information, where available. Also includes `TOMBPC.DAT` script information, `CDAUDIO.WAD` and `CUTSEQ.PAK` information.)

Foreword
--------

[quote]
The Rosetta Stone was the key that unlocked the mysteries of Egyptian hieroglyphics. It contains an inscription praising King Ptolemy V, which is repeated
three times -- once in hieroglyphic, once in demotic, and once in Greek. By translating the Greek, comparisons could be made with the demotic and hieroglyphic
versions, providing an invaluable lexicon with which to translate other hieroglyphic works. The efforts that went into making the document you are now reading
could be likened to a form of digital archæology, and hopefully this document will provide sufficient information for others to decipher and create their own
``TR-hieroglyphic'' works.

Since 2003 the Tomb Raider community, especially programmers and resource hacking enthusiasts used an outdated document called TRosettaStone, which hadn't been updated since 1999. There was an updated version available, which was done by E. Popov -- that's the one which we will use as basis for this document. Also, this document will widely borrow information from TREP user's manual, NGLE manual, and a bunch of TRF threads about internal game engine structures. Maybe other documents will be used as well, but in any case, you will get a reference and a link at the end of this text.

However, while original TRosettaStone and update by Popov were aimed primarily at simply exploring already existing game assets, such as levels, sound files, scripts, etc. This document is being created as a reference for programmers who are creating open-source reimplementations of original game engines. Because of this, we will explore not only game file formats, but also internal game logic, procedures and other related aspects. It will be updated synchronously with development of OpenTomb, one of such reimplementation projects, which has received lots of feedback from the community.

Description
~~~~~~~~~~~

This document contains detailed descriptions of the classic-era Tomb Raider data file formats. It is assumed that the reader has knowledge and experience programming in C or C++ and has at least a passing familiarity with graphics programming. This document is self-contained; all hyperlinks refer only to itself. All information in this document was derived independently, without the aid or assistance of anyone at Core Design or Eidos. As such, the information in this document may contain errors or omissions, and many structure and variable names were deduced from the interpretation of the data (and therefore could be misleading or completely wrong). However, we re-use certain variable and function names from original Tomb Raider debug builds and mappings/symbols from the leaked Tomb Raider Chronicles PSX SDK. All the information in this document was tested and is therefore plausible, but could also be a misinterpretation. All information herein is provided as is — you get what you pay for, and this one’s free. This is a spare-time project that set out to document the Tomb Raider file formats.

Conventions
~~~~~~~~~~~

Generally, game versions are referenced by abbreviations:

* *TR1* refers to Tomb Raider and Tomb Raider: Unfinished Business
* *TR2* refers to Tomb Raider II and Tomb Raider: The Golden Mask
* *TR3* refers to Tomb Raider III and Tomb Raider: The Lost Artifact
* *TR4* refers to Tomb Raider: The Last Revelation
* *TR5* refers to Tomb Raider: Chronicles

[NOTE]
====
When level formats are concerned, *TR4* usually applies not only to original game, but to 'custom levels' built by fans using 'Tomb Raider Level Editor' (`winroomedit.exe`) version `.49`, used to work with TR4-specific level file format. This level editor version is the only one level editor officially released by Eidos / Core, along with TR5.
====

Also, if external programs and utilities are concerned, here's abbreviations for them:

* *TRLE* refers to Tomb Raider Level Editor -- an official tool by Core Design used to build levels.
* *NGLE* refers to TRLE version which was unofficially patched and now extensively used by level editing community.
* *Dxtre3d* refers to so-called 'unofficial' level editor developed by Felix aka 'Turbo Pascal'.
* *TREP* refers to a binary patcher which is used to patch 'TR4 engine' in its 'Level Editor' version (bundled with TR5) for some advanced features and upgrades by level editing community.
* *TRNG* is another patcher with same purpose as TREP, however, incompatible with it. TRNG offers even more advanced features and upgrades to old 'TR4 engine'.
* *FLEP* refers to a similar patcher as 'TREP', which is used for same 'TR4 engine', albeit previously modified by 'TRNG'.

When there is some version-specific info about certain structures or methods, this information will be marked as *TRx ONLY*, where *x* means game version(s). Additionally, if the information is specific to TR2 onwards, it is highlighted in [red]*RED*. Likewise, information specific to TR3 is highlighted in [green]*GREEN*. Information specific to Tomb Raider IV(TR4) is highlighted in [blue]*BLUE*, and Tomb Raider Chronicles info is highlighted in [purple]*PURPLE*.

Current unknowns
~~~~~~~~~~~~~~~~

. Room light structure from TR4 needs additional description.
. Same for TR5 room light structure.
. Exact description of what is exactly "room layer" in TR5.
. Clarify the meaning of 'Bit 4' in <<tr2_room_vertex>> structure.
. Clarify, what's the purpose of `Normal` field in <<tr5_room_vertex>> structure, and if really `Attributes` field was removed.
. Whole `tr5_room` structure needs detailed analysis with all its extra 'Unknown' fields.
. Clarify fog bulb values which affect its radius.

Copyright note
~~~~~~~~~~~~~~

Tomb Raider, Tomb Raider Gold, Unfinished Business, Tomb Raider II, Tomb Raider III, Tomb Raider: The Last Revelation, Tomb Raider Chronicles, Lara Croft, and all images and data within the data files and game engine are Copyright © Square Enix.


The Fundamentals
----------------

Overview
~~~~~~~~

In this section, we'll try to describe basic file types of Tomb Raider, as well as basic data types used in structures.

File types
^^^^^^^^^^

Tomb Raider is driven by various sets of files -- level files, script files, FMVs, audio tracks and sound files. In TR4 and TR5, there is also specific file type which contains cutscene data -- 'cutseq pack'.

The script files
++++++++++++++++

The script file structure differs from version to version.

In TR1, all script info was embedded into executable (`tomb.exe`). TR2 and TR3 had unified `TOMBPC.DAT` file, which contains all the text strings describing the various elements in the game (e.g. the game engine knows about '``Key 1'''; it looks in `TOMBPC.DAT` to determine the name to be displayed in Lara's inventory, such as '``Rusty Key''' or '``Taste rostige''' or '``Cle Rouillee'''), the level and cut-scene filenames (e.g. `WALL.TR2`, `CUT3.TR2`), the order in which they are to be played, and various per-level and per-game configuration options (e.g. what weapons and objects Lara starts the level with, whether or not the "cheat" codes work, etc.).

TR4 and TR5 introduced other script structure, where actual script defining gameflow was separated from text strings used in game -- hence, both TR4 and TR5 have two `.DAT` files -- `SCRIPT.DAT` and `LANGUAGE.DAT`, where `LANGUAGE` differs depending on regional origin of the game -- `US.DAT`, `FRENCH.DAT`, `JAPANESE.DAT`, and so on.

The level files
+++++++++++++++

The level files, `{level-name}.PHD/TUB/TR2/TR4/TRC`, contain everything about the level, including the geographical geometry, the geometry (meshes) of all animate and inanimate objects in the level, all the textures and colour data, all animation data, index information (and, in TR1, TR4 and TR5 -- also the 'actual sound sample data') for all sounds, accessibility maps -- everything necessary to run the game. For whatever reason, Core has included everything in one file instead of breaking it up into logical groupings; this means that every level contains all the meshes, textures, sound information, and animation data for Lara and all of her weapons. There are a fair number of other redundancies, too.

[NOTE]
====
Since TR4, level file is divided 'in several chunks', each of them being compressed using 'zlib'. Usually, each chunk of compressed data is preceded by two values defining 'uncompressed size' of the chunk and 'compressed size' of the chunk. Therefore, engine at first allocates a memory block equal to 'uncompressed size', and decompresses a chunk with 'compressed size' into allocated memory.
====

Another type of compression is used for 'sound samples' -- they are kept in 'MS-ADPCM' wave format, preceiding with 'uncompressed size' and 'compressed size' of the sample.

[NOTE]
====
While 'compressed size' defines the whole size of embedded `.WAV` file, 'uncompressed size' defines the size of raw PCM data size in '16-bit, 22050 kHz, mono' format. However, 'uncompressed size' does not necessarily equal to a value derived from 'compressed size' by wave type conversion, because MS-ADPCM codec tends to leave a bit of silence in the end of the file (which produces audible interruption in looped samples).
====

It's good to note the origins of level file extension. While it is obvious that TR2/TR4/TRC extensions specify game version, `.PHD` is actually abbreviation for one of the key developers of Tomb Raider 1: 'Phil H. Daniels'. Looks like that this programmer contributed a lot of the code to early version of Tomb Raider, because phd also became a prefix for several helper functions in source code, like `phd_sin`, `phd_cos`, and so on. Most likely, he was responsible for developing level file structure of Tomb Raider.

FMVs (Full Motion Videos)
+++++++++++++++++++++++++

TR1-3 shared the same proprietary Eidos codec for videos, called 'Escape'. The extension for such files is `.RPL`, that's why they occasionally (and mistakingly) called Replay codec. Signature feature of RPL videos is that they are always interlaced with black stripes; most likely, this was used to conserve disk space (however, 'PlayStation' videos were in `.STR` format, which is basic MPEG compression, and they had no interlacing -- but suffered from blocking issues). In TR1 and TR2, framerate was limited to 15 FPS, while in TR3 it was doubled to 30 FPS.

For a long time, Escape codec was largely unexplored and barely reverse-engineered; there was only an abandoned open source 'Mplayer' implementation for some Escape codec versions, but recent 'ffmpeg' revisions feature fully functional decoder for Escape videos.

Since TR4, all FMVs are in 'Bink Video' format, which is much more common and easy to rip, convert and explore.

Sound files -- audio tracks
+++++++++++++++++++++++++++

TR1 and TR2 used 'CD-Audio' tracks for in-game music, and therefore, they needed auxilary CD-audio fed into the soundcard. That's the reason why most contemporary PCs have issues with audiotrack playback in these games - such setup is no longer supported in modern CD/DVD/BD drives, and digital pipeline is not always giving the same result. Currently, various modernized game repacks (such as 'Steam' or 'GOG' releases) officially features no-cd patches with embedded 'MP3 player', which takes place of deprecated CD-Audio player.

In TR3, we have somewhat special audiotrack setup. Audio format was indeed changed to simple 'WAV (MS-ADPCM codec)', but all tracks were embedded into `CDAUDIO.WAD` file, which also contained a header with a list of all tracks and their durations. So, when game requests an audiotrack to play, it takes info on needed track from `CDAUDIO.WAD` header, and then goes straight to an offset for this track into it.

In TR4-5, track format remained the same (MS-ADPCM), but tracks were no longer embedded into `CDAUDIO.WAD`. Instead, each track was saved as simple `.WAV` file, and file names themselves were embedded into executable. Hence, when TR4-5 plays an audiotracks, it refers to internal filename table, and then loads an audiotrack with corresponding name.

[NOTE]
====
Audio tracks can be 'looped' or 'one-shot'. Looped tracks are usually contain background ambience (these creepy sounds heard in the beginning of 'Caves', and so on), but occasionally they can use music (e. g., 'Jeep theme' from TR4). One-shot tracks are used for musical pieces which are usually triggered on certain event, and also for ``voice chatting'' (e. g. approaching the monk from ``Diving Area'' in TR2).

As both 'looped' and 'one-shot' tracks use the same audio playing routine, there's no chance both 'looped' and 'one-shot' tracks could be played simultaneously. This is the reason why background ambience stops and restarts every time another (one-shot) track is triggered. However, this limitation was lifted in 'TREP' and 'TRNG'.
====

Sound files -- samples
++++++++++++++++++++++

TR2 and TR3 also featured external sound sample files, which allowed to share samples between all level files. This sound file is called `MAIN.SFX`, and usually placed in `DATA` subfolder. Hence, engine loads sound samples not from level files (as it's done in TR1, TR4 and TR5 -- see above), but rather from this `MAIN.SFX` file.

Cut sequence packs
++++++++++++++++++

TR4 and TR5 featured special data type containing all the necessary information to play 'in-game cutscenes'. While in earlier games such info was embedded into the level file itself, and generally, cutscenes themselves were separate level files (easily distinguished by their filenames, e.g. `CUT1.TR2` etc.), TR4 changed this approach, and cutscenes could be loaded and played right inside level files at runtime.

The data for such cutscene setup was packed into single file titled `CUTSEQ.PAK` in TR4 or `CUTSEQ.BIN` in TR5. There will be a special section describing whole cutseq file format.

Basic data types
^^^^^^^^^^^^^^^^

For the purposes of further discussion, the following are assumed:

[width="50%",cols=">1,<5",align="center"]
|====
| `int8_t`   | specifies an 8-bit signed integer (range -128..127)
| `uint8_t`  | specifies an 8-bit unsigned integer (range 0..255)
| `int16_t`  | specifies a 16-bit signed integer (range -32768..32767)
| `uint16_t` | specifies a 16-bit unsigned integer (range 0..65535)
| `int32_t`  | specifies a 32-bit signed integer (range -2147483648..2147483647)
| `uint32_t` | specifies a 32-bit unsigned integer (range 0..4294967295)
| `float`    | specifies a 32-bit IEEE-754 floating-point number
|====

There are also specific Tomb Raider data types (packed or hybrid), which will be mentioned specially.

All multi-byte integers (`{u}int16_t`, `{u}int32_t`) are stored in little-endian (Intel-x86, etc.) format, with the least significant byte stored first and the
most significant byte stored last. When using this data in platforms with big-endian (PowerPC, etc.) number format, be sure to reverse the order of bytes.

Data alignment is something one has to be careful about. When some entity gets an address that is a multiple of latexmath:[$n$], it is said to be latexmath:[$n$]-byte aligned. The reason
it is important here is that some systems prefer multibyte alignment for multibyte quantities, and compilers for such systems may pad the data to get the
``correct'' alignments, thus making the in-memory structures out of sync with their file counterparts. However, a compiler may be commanded to use a lower level
of alignment, one that will not cause padding. And for TR's data structures, 2-byte alignment should be successful in nearly all cases, with exceptions noted
below.

To set single-byte alignment in any recent compiler, use the following compiler directive:

[source,cpp]
--------------------------
#pragma pack(push, 1)
--------------------------

To return to the project's default alignment, use the following directive:

[source,cpp]
----------------------
#pragma pack(pop)
----------------------

Note about float-phobic nature of Tomb Raider
+++++++++++++++++++++++++++++++++++++++++++++

In 90% of all cases, Tomb Raider engines use integer numbers, even for geometry calculations and animation interpolations. The root of this setup lies in multi-platform nature of the code, which was simultaneously written for PC and PlayStation. While PCs had enough computational power to deal with floats at that time, PlayStation relied primarily on integers.

However, some internal variables and constants (like drawing distance and fog distance constants) are PC-specific and stored in floating point numbers. Also, last game in series, TR5, extensively used floating-point numbers for certain data types -- like colours, vertices, lights and some coordinates.

Coordinates
^^^^^^^^^^^

The world coordinate system is oriented with the latexmath:[$X-Z$] plane horizontal and latexmath:[$Y$] vertical, with latexmath:[$-Y$] being ``up'' (e.g. decreasing latexmath:[$Y$] values indicate
increasing altitude). The world coordinate system is specified using `int32_t` values; however, the geography is limited to the latexmath:[$+X$]/latexmath:[$+Z$] quadrant for reasons that are
explained below. Mesh coordinates are relative and are specified using `int16_t`.

There are some additional coordinate values used, such as ``the number of 1024-unit blocks between points A and B'';  these are simply scaled versions of more conventional coordinates.

Colours
^^^^^^^

All colours in TR are specified either explicitly (using either the <<tr_colour>> structure, described below, 16-bit structures or 32-bit structures) or implicitly, by indexing one of the palettes. However, it is only applicable to TR1-3 -- there is no palette in TR4 and TR5.

In TR1-3, mesh surfaces could be either 'coloured' or 'textured'. 'Coloured' surfaces are ``painted'' with a single colour that is either specified explicitly or using an index into the palette.

Beginning from TR4, coloured faces feature was removed, so each face must have a texture attached to it.

Textures
^^^^^^^^

'Textured' surfaces map textures (bitmapped images) from the texture tiles (textiles) to each point on the mesh surface.  This is done using conventional UV mapping, which is specified in ``Object Textures'' below; each object texture specifies a mapping from a set of vertices to locations in the textile, and these texture vertices are associated with position vertices specified here. Each textile is a 256x256 pixels wide area.

The 16-bit textile array, which contains <<tr_textile16>> structures, specifies colours using 16-bit ARGB, where the highest bit
(`0x8000`) is a crude alpha channel (really just simple transparency -- '0 = transparent', '1 = opaque').  The next 5 bits (`0x7c00`) specify the red channel, the next 5 bits (`0x03e0`) specify the green channel, and the last 5 bits (`0x001f`) specify the blue channel, each on a scale from 0..31.

*TR1-3 ONLY:* If, for some reason, 16-bit textures are turned off, all colours and textures use an 8-bit palette that is stored in the level file.  This palette consists of a 256-element array of <<tr_colour>> structures, each designating some colour;  textures and other elements that need to reference a colour specify an index (0..255) into the `Palette[]` array.  There is also a 16-bit palette, which is used for identifying colours of solid polygons.  The 16-bit palette contains up to 256 four-byte entries;  the first three bytes are a
<<tr_colour>>, while the last byte is ignored (set to 0).

*TR4-5 ONLY:* The 32-bit textile array, which contains <<tr4_textile32>> structures, specifies colours using 32-bit ARGB, where the highest byte is the alpha channel (255 means the texel is fully opaque, 0 the texel is fully transparent).  The next bytes specify (in this order) the red / green / blue channels. The 16 and 32-bit textile arrays depict the same graphics data, but of course the 32-bit array has a better colour resolution. It's the one used if you select a 32 bits A8R8G8B8 texture format in the setup menu from TR4 and TR5.

Objects
^^^^^^^

There are two basic types of objects in TR2 -- meshes and sprites.

_Meshes_ are collections of textured or coloured polygons that are assembled to
form a three-dimensional object (such as a tree, a tiger, or Lara herself). The ``rooms'' themselves are also composed of meshes. Mesh objects may contain more
than one mesh; though these meshes are moved relative to each other, each mesh is rigid.

_Sprites_ are two-dimensional images that are inserted into
three-dimensional space, such as the ``secret'' dragons, ammunition, medi-packs, etc. There are also animated sprite sequences, such as the fire at the end of
``The Great Wall.'' Core had presumably used this method to reduce CPU utilization on the PlayStation and/or the earlier PCs. Sprites become less and less
abundant; TR2 has very few scenery sprites, and TR3's pickups are models instead of sprites. Objects are referenced in one of two ways -- as an offset into an
array (e.g. `Moveables[i]`) or using an identifying tag (`ObjectID`). In the latter case, the related array (`Items[]`, `Moveables[]`, etc.) is searched until a
matching `ObjectID` is found.

Animations
^^^^^^^^^^

There are three basic types of animations in TR, two corresponding with textures -- sprite animations and animated textures -- and one corresponding directly with meshes.

Sprite animations
+++++++++++++++++

Sprite animation (sprite sequences) consists simply of a series of sprites that are to be displayed one after another, e.g. grenade explosions. Sprite animations were quite common in earlier games (TR1 and TR2), while in TR3 onwards there are almost no sprite animations -- only notable example is fire particle sprites and water splash effect.

Animated textures
+++++++++++++++++

These are either a list of textures cycled through in endless loop, or (in TR4-5) a single texture with shifting coordinates, creating an illusion of ``rolling'' image.

Mesh animations
+++++++++++++++

Mesh animations are much more complex than sprite and texture animations, and done by what is essentially a skeletal-modeling scheme. These involve some arrays (Frames[] and MeshTree[]) of offsets and rotations for each element of a composite mesh. Frames are then grouped into an array (Animations[]) that describes discrete ``movements'', e.g. Lara taking a step or a tiger striking with its paw. The animations are “sewn together” by a state change array and an animation dispatch array, which, together with state information about the character, ensure that the animation is fluid (e.g. if Lara is running and the player releases the RUN key, she will stop; depending upon which of her feet was down at the time, either her left or right foot will strike the floor as part of the ``stop'' animation. The correct animation (left foot stop vs. right foot stop) is selected using these structures and the state information).


Lighting
^^^^^^^^

There are two main types of lighting in Tomb Raider, 'constant' and 'vertex'. Constant lighting means that all parts of an object have the same illumination, while in vertex lighting, each polygon vertex has its own light value, and the illumination of the polygon interiors is interpolated from the vertex values.

Furthermore, lighting can be either internal or external. Internal lighting is specified in an object’s data, external lighting is calculated using the room’s light sources (ambient light, point light sources, spotlights (TR4-5), dynamic lights).

When available, external lighting also uses the vertex normals to calculate the incoming light at each vertex. Light intensities are described either with a single value or with a 16 bits color value (you can see it more like a ``color filter''), depending mainly on the TR version.

Light intensities are described with a single value in TR1 and a pair of values in TR2 and TR3; the paired values are almost always equal, and the pairing may reflect some feature that was only imperfectly implemented, such as off/on or minimum/maximum values. In TR1 and TR2, the light values go from 0 (maximum light) to 8192 (minimum light), while in TR3, the light values go from 0 (minimum light) to 32767 (maximum light).

Sound samples
^^^^^^^^^^^^^

There are two ways for sound samples to play.

First one is basically sound emitter sitting at a static global position in level, and continuously emitting specified sound (such as waterfalls -- these are in `SoundSources[]`). Second one is triggered sounds -- these are sounds played when some event happens, such as at certain animation frames (footsteps and other Lara sounds), when doors open and close, and when weapons are fired.

Either way, each played sound is referred to using a three-layer indexing scheme, to provide a maximum amount of abstraction. An internal sound index references `SoundMap[]`, which points to a `SoundDetails[]` record, which in turn points to a `SampleIndices[]` entry, which in turn points to a sound sample. `SoundDetails[]`, contains such features as sound intensity, how many sound samples to choose from, among others. The sound samples themselves are in Microsoft WAVE format, and, as already mentioned, they are embedded either in the data files (TR1, TR4 and TR5) or in a separate file (`MAIN.SFX`) in TR2 and TR3. 

Basic Data Structures
~~~~~~~~~~~~~~~~~~~~~

Much of the .TR2 file is comprised of structures based on a few fundamental data structures, described below.

Colour structure
^^^^^^^^^^^^^^^^

This is how most colours are specified.

[[tr_colour]]
[source,cpp]
----
struct tr_colour   // 3 bytes
{
    uint8_t Red;        // Red component (0 -- darkest, 255 -- brightest)
    uint8_t Green;      // Green component (0 -- darkest, 255 -- brightest)
    uint8_t Blue;       // Blue component (0 -- darkest, 255 -- brightest)
};
----
(Some compilers will pad this structure to make 4 bytes; one must either read and write 3 bytes explicitly, or else use a simple array of
bytes instead of this structure.)

And as mentioned earlier, the 16-bit palette uses a similar structure:

[source,cpp]
----
struct tr_colour4  // 4 bytes
{
    uint8_t Red;
    uint8_t Green;
    uint8_t Blue;
    uint8_t Unused;
};
----

In TR5, there is new additional colour type composed of floating-point numbers. This type is primarily used in light structures.

[source,cpp]
----
struct tr5_colour  // 4 bytes
{
    float Red;
    float Green;
    float Blue;
    float Unused;   // Usually filler value = 0xCDCDCDCD
};
----

Vertex structure
^^^^^^^^^^^^^^^^

This is how vertices are specified, using relative coordinates.  They are generally formed into lists, such that other entities (such as
quads or triangles) can refer to them by simply using their index in the list.

[source,cpp]
----
struct tr_vertex   // 6 bytes
{
    int16_t x;
    int16_t y;
    int16_t z;
};
----

As with colours, TR5 introduced additional vertex type comprised of floating-point numbers:

[source,cpp]
----
struct tr5_vertex   // 12 bytes
{
    float x;
    float y;
    float z;
};
----

Rectangular (quad) face definition
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Four vertices (the values are indices into the appropriate vertex list) and a texture (an index into the object-texture
list) or colour (index into 8-bit palette or 16-bit palette).  If the rectangle is a coloured polygon (not textured), the .Texture element contains two indices:
the low byte (`Texture & 0xFF`) is an index into the 256-colour palette, while the high byte (`Texture >> 8`) is in index into the 16-bit palette, when present. A
textured rectangle will have its vertices mapped onto all 4 vertices of an object texture, in appropriate correspondence.

[[tr_face4]]
[source,cpp]
----
struct tr_face4    // 12 bytes
{
    uint16_t Vertices[4];
    uint16_t Texture;
};
----

`Texture` field can have the bit 15 set: when it is, the face is 'double-sided' (i.e. visible from both sides). 

*TR1-3 ONLY:* If the rectangle is a coloured polygon (not textured), the .Texture element contains two indices: the low byte (`Texture & 0xFF`) is an index into the 256-colour palette, while the high byte (`Texture >> 8`) is in index into the 16-bit palette, when present.

TR4 and later introduced an extended version only used for meshes, not for triangles and quads making rooms:

----
struct tr4_mesh_face4    // 12 bytes
{
    uint16_t Vertices[4];
    uint16_t Texture;
    uint16_t Effects    // TR4-5 ONLY: alpha blending and environment mapping
};
----

The only difference is the extra field `Effects`. It has this layout:

 * 'Bit 0:' if set, face has 'additive alpha blending' (same meaning that when the `Attribute` field of <<tr2_object_texture>> is 2).
 * 'Bits 1-7:' strength of 'environment mapping' effect (so-called ``shiny effect'' in TRLE community). Environment map is derived from special pre-rendered texture. The bigger the value is, the more visible the effect is.
 
 .  Note that only externally lit meshes can use environment mapping in original engines. If you use it with internally lit meshes, you will crash the game.
 . TR4 engine doesn't support environmental map for Lara's joints. It simply wasn't implemented, so if you apply effect to Lara joints, game will crash. For TR5, a special object called 'Lara's catsuit' was developed to support environmental map on transformed meshes.


Triangular face definition
^^^^^^^^^^^^^^^^^^^^^^^^^^

This structure has the same layout than the quad face definition, except a textured triangle will have its vertices mapped 'onto the first 3 vertices of an object texture, in appropriate correspondence'. Moreover, a triangle has only 3 vertices, not 4.

[[tr_face3]]
[source,cpp]
----
struct tr_face3    // 8 bytes
{
    uint16_t Vertices[3];
    uint16_t Texture;
};

struct tr4_mesh_face3    // 10 bytes
{
    uint16_t Vertices[3];
    uint16_t Texture;
    uint16_t Effects    // TR4-5 ONLY: alpha blending and environment mapping strength
};
----
 
All the info about `Texture` and `Effects` field is also similar to same info from <<tr_face4>> definition.

8-bit texture tile
^^^^^^^^^^^^^^^^^^

Each `uint8_t` represents a pixel whose colour is in the 8-bit palette.

[source,cpp]
----
struct tr_textile8    // 65536 bytes
{
    uint8_t Tile[256 * 256];
};
----

16-bit texture tile
^^^^^^^^^^^^^^^^^^^

Each `uint16_t` represents a pixel whose colour is of the form ARGB, MSB-to-LSB:

1-bit transparency (0 ::= transparent, 1 ::= opaque) (`0x8000`)  +
5-bit red channel (`0x7c00`)  +
5-bit green channel (`0x03e0`)  +
5-bit blue channel (`0x001f`)

[[tr_textile16]]
[source,cpp]
----
struct tr_textile16    // 131072 bytes
{
    uint16_t Tile[256 * 256];
};
----
 
32-bit texture tile
^^^^^^^^^^^^^^^^^^^

Each `uint32_t` represents a pixel whose colour is of the form ARGB, (A = most significant byte), each component being one byte. 

[[tr4_textile32]]
[source,cpp]
----
struct tr4_textile32    // 262144 bytes
{
    uint32_t Tile[256 * 256];
};
----

Room Geometry
~~~~~~~~~~~~~

Overview
^^^^^^^^

A 'room' in TR2 is simply a rectangular three-dimensional area. A room may be ``indoors'' or ``outdoors,'' may or may not be enclosed, may be
accessible or inaccessible to Lara, may or may not contain doors or objects.

All rooms have ``portals,'' called ``doors'' in some documentation, which are pathways to adjacent rooms. There are two kinds of portals -- visibility portals and collisional portals. Visibility portals are for determining how much of a room (if any) is visible from another room, while collisional portals are for enabling an object to travel from one room to another.

The visibility portals are most likely for doing ``portal rendering'', which is a visibility-calculation scheme that goes as follows: the viewpoint is a member of some room, which is then listed as visible from it. This room's portals are checked for visibility from that viewpoint, and visible portals have their opposite-side rooms marked as visible. These rooms are then checked for portals that are visible from the viewpoint through the viewpoint's room's portals, and visible ones have their opposite-side rooms marked as visible. This operation is repeated, with viewing through intermediate portals, until all visible portals have been found. The result is a tree of rooms, starting from the viewpoint's room; only those rooms and their contents need to be rendered.

It is clear that both visibility and collision calculations require that objects have room memberships given for them, and indeed we shall find that most map objects have room memberships.

Rooms may overlap; as we shall see, this is involved in how horizontal collisional portals are implemented. However, different rooms may overlap without either
being directly accessible from the other; there are several inadvertent examples of such ``5D space'' in the Tomb Raider series. The only possibly deliberate
example I know of is the flying saucer in ``Area 51'' in TR3, whose interior is bigger than its exterior.

A room can have an ``alternate room'' specified for it; that means that that room can be replaced by that alternate as the game is running. This trick is used
to produce such tricks as empty rooms vs. rooms full of water, scenery rearrangements (for example, the dynamited house in ``Bartoli's Hideout'' in TR2), and so
forth. An empty room is first created, and then a full room is created at its location from a copy of it. The empty room then has that full room set as its
alternate, and when that room is made to alternate, one sees a full room rather than an empty one.

The rooms are stored sequentially in an array, and ``Room Numbers'' are simply indices into this array (e.g. ``Room Number 5'' is simply `Rooms[5]`; the first
room is `Rooms[0]`).

Rooms are divided into _sectors_ (or _squares_), which are 1024x1024 unit squares that form a grid on the latexmath:[$X-Z$] plane. Sectors are the defining area for floor/ceiling heights and triggers (e.g. a tiger appears and attacks when Lara steps on a given square); the various attributes of each sector are stored in the Sector Data (described in this section) and the <<FloorData>>.  As an aside, Sectors correspond to the ``squares,'' easily visible in all of the Tomb Raider games, that experienced players count when gauging jumps;  they also account for some of the game's less-appealing graphic artifacts. Careful tiling and texture construction can make these ``squares'' almost invisible.

Rooms have two kinds of surfaces, rendered and collisional, much like the two kinds of portals. The former are what is seen, while the latter control how
objects interact with the world geometry. Furthermore, these two types are specified separately in the room data.

Rooms are defined with a complex structure, which is described below ``inside-out,'' meaning that the smaller component structures are described first, followed
by the larger structures that are built using the smaller structures.

Room Structures
^^^^^^^^^^^^^^^

Room header
+++++++++++

latexmath:[$X / Z$] indicate the base position of the room mesh in world coordinates (latexmath:[$Y$] is always zero-relative)

[[tr_room_info]]
[source,cpp]
----
struct tr_room_info    // 16 bytes
{
    int32_t x;             // X-offset of room (world coordinates)
    int32_t y;             // Y-offset of room (world coordinates) - only in TR5
    int32_t z;             // Z-offset of room (world coordinates)
    int32_t yBottom;
    int32_t yTop;
};
----

`yBottom` is actually largest value, but indicates 'lowest' point in the room.
`yTop` is actually smallest value, but indicates 'highest' point in the room.

TR5 uses an extended version of this structure:

[source,cpp]
----
struct tr5_room_info    // 20 bytes
{
    int32_t x;             // X-offset of room (world coordinates)
    int32_t y;             // Y-offset of room (world coordinates) - only in TR5
    int32_t z;             // Z-offset of room (world coordinates)
    int32_t yBottom;
    int32_t yTop;
};
----

The additional `y` value is usually 0.

Portal structure
++++++++++++++++

These portals, sometimes called ``doors'', define the view from a room into another room. This can be through a ``real'' door, a window,
or even some open area that makes the rooms look like one big room. Note that ``rooms'' here are really just areas; they aren't necessarily enclosed.  The
portal structure below defines 'only visibility portals', not an actual moveable door mesh, texture, or action (if any).  And if the portal is not properly oriented, the camera cannot ``see'' through it.

[source,cpp]
----
struct tr_room_portal  // 32 bytes
{
    uint16_t  AdjoiningRoom; // Which room this portal leads to
    tr_vertex Normal;
    tr_vertex Vertices[4];
};
----

`Normal` field tells which way the portal faces (the normal points _away_ from the adjacent room; to be seen through, it must point _toward_ the viewpoint).

`Vertices` are the corners of this portal (the right-hand rule applies with respect to the normal). If the right-hand-rule is not followed, the portal will  contain visual artifacts instead of a viewport to `AdjoiningRoom`.

Room Sector structure
+++++++++++++++++++++

All the geometry specified here is 'collisional geometry'.

[source,cpp]
----
struct tr_room_sector // 8 bytes
{
    uint16_t FDindex;    // Index into FloorData[]
    uint16_t BoxIndex;   // Index into Boxes[] (-1 if none)
    uint8_t  RoomBelow;  // 255 is none
    int8_t   Floor;      // Absolute height of floor
    uint8_t  RoomAbove;  // 255 if none
    int8_t   Ceiling;    // Absolute height of ceiling
};
----

`Floor` and `Ceiling` are signed numbers of 256 units of height (relative to 0) -- e.g. Floor `0x04` corresponds to latexmath:[$Y = 1024$] in world coordinates. Therefore, 256 units is a 'minimum vertical stride of collisional geometry'. However, this rule could be broken by specific entities, which Lara can stand on. But 'horizontal' sector dimensions, which, as mentioned earlier, are 1024 x 1024 (in world coordinates), could not. Therefore, minimal horizontal platform dimensions, on which Lara can stand and grab, are 1024 x 1024 as well.

[NOTE]
====
This implies that, while latexmath:[$X$] and latexmath:[$Z$] can be quite large, latexmath:[$Y$] is constrained to -32768..32512.
====

`Floor` and `Ceiling` value of `0x81` is a magic number used to indicate impenetrable walls around the sector. `Floor` values are used by
the game engine to determine what objects Lara can traverse and how. Relative steps of 1 (-256) can be walked up; steps of 2..7 (-512..-1792) can/must be jumped
up; steps larger than 7 (-2048..-32768) cannot be jumped up (too tall).

`RoomAbove` and `RoomBelow` values indicate what neighboring rooms are in these directions -- the number of the room below this one and the number of the room above this one. If `RoomAbove` is not 'none', then the ceiling is a 'collisional portal' to that room, while if `RoomBelow` is not 'none', then the floor is a 'collisional portal' to that room.

Also, `RoomBelow` value is extensively used by engine to determine actual sector data and triggers in so-called 'stacked room setups', when one room is placed above another through collisional portal. The thing is, engine uses sector data and triggers 'only for the lowest sector' of the stacked room setup, so it recursively scans for a lowest room to determine which sector to use.

`FDindex` is a pointer to specific entry in <<FloorData>> array, which keeps all the information about sector flags, triggers and other parameters. While it is implied that one `FDindex` entry may be shared between several sectors, it is usually not the case with original Tomb Raider levels built with 'TRLE'. However, 'Dxtre3d' takes advantage of this feature and may optimize similar sectors to share same FDindex pointer.

`BoxIndex` is a pointer to special <<Boxes>> array entry, which is basically a subset of sectors with same height configuration. It is primarily used for AI pathfinding (see the <<non-player-character-behaviour,Non-player character behaviour>> chapter for more details).

*TR3-5 ONLY:* In these games, `BoxIndex` field is more complicated, and actually contains 'two packed values'. Bits 4-14 contain the 'actual box index', and bits 0-3 contain 'material index', which is used to produce specific footstep sound, when Lara is walking or running in this sector. On PlayStation game versions, this index was also used to determine if footprint textures should be applied to this particular place.

Majority of 'material index' values are the same across game versions, but some of them exist only in particular game. Here is the description:

* *0* -- Mud
* *1* -- Snow (TR3 and TR5 only)
* *2* -- Sand
* *3* -- Gravel
* *4* -- Ice (TR3 and TR5 only)
* *5* -- Water '(unused, as water footstep is only activated in water rooms)'
* *6* -- Stone '(unused, as it is default footstep sound)'
* *7* -- Wood
* *8* -- Metal
* *9* -- Marble (TR4 only)
* *10* -- Grass
* *11* -- Concrete
* *12* -- Old wood
* *13* -- Old metal

Mud, snow, sand, grass and maybe some other materials produce footprints in PlayStation version.

Furthermore, in TR3-5, 'actual box index' may contain special value 2047, which is most likely indicates that this sector is a slope on which Lara can slide (and, therefore, possibly impassable by most NPCs).

Room Light structure
++++++++++++++++++++

[NOTE]
====
TR engines always used static room lights only for processing lighting on entities (such as Lara, enemies, doors, and others). This is called 'external lighting'. For room meshes, they used so-called 'internal, or 'pre-baked' lighting, which is done on level building stage: lights are calculated and applied to room faces via vertex colours. There is no way to change room lighting when the level is compiled -- meaning, any changes in light positions, intensities and colour won't affect room faces.
====

There are four different types of room light structures. First one is used in TR1-2, second is used in TR3, third is used in TR4, and fourth is used in TR5. Here is the description of each:

.TR1-2 Room Lighting

[source,cpp]
----
struct tr_room_light   // 18 bytes (TR2: 24 bytes)
{
     int32_t x, y, z;       // Position of light, in world coordinates
    uint16_t Intensity1;    // Light intensity
    uint32_t Fade1;         // Falloff value
};
----

`X/Y/Z` are in world coordinates. `Intensity1/Intensity2` are almost always equal. This lighting only affects 'externally-lit' objects. Tomb Raider 1 has only the first of the paired `Intensity` and `Fade` values.

`Intensity1` ranges from 0 (dark) to 0x1FFF (bright). However, some rooms occasionally have some lights with intensity greater than 0x1FFF (for example, look at room #9, 2nd light in `level1.phd`). `Fade1` is the maximum distance the light shines on, and ranges from 0 to 0x7FFF. 

TR2 uses an extended version of this structure:

[source,cpp]
----
struct tr2_room_light   // 24 bytes
{
     int32_t x, y, z;       // Position of light, in world coordinates
    uint16_t Intensity1;    // Light intensity
    uint16_t Intensity2;    // Only in TR2
    uint32_t Fade1;         // Falloff value
    uint32_t Fade2;         // Only in TR2
};
----

`Intensity2` and `Fade2` values are seemingly not used. `Intensity1` can go very well beyond 0x1FFF, right to 0x7FFF (ultra bright light). Above 0x7FFF, it is always black, so the number is pseudo-signed (negative values are always treated as zero).

.TR3 Room Lighting

[source,cpp]
----
struct tr3_room_light   // 24 bytes
{
        int32_t x;             // Position of light, in world coordinates
        int32_t y;
        int32_t z;
     tr_colour4 Colour;        // Colour of the light
       uint32_t Intensity;
       uint32_t Fade;          // Falloff value
};
----

`Intensity` is the power of the light and ranges mainly from 0 (low power) to 0x1FFF (high power). Though, values greater than 0x1FFF do exist and their meanings are unknown.
`Fade` is the distance max the light can shine on. Range is mainly from 0 to 0x7FFF, but negative values do exist and their meanings are unknown.

.TR4 Room Lighting

[source,cpp]
----
struct tr4_room_light   // 46 bytes
{
        int32_t x, y, z;       // Position of light, in world coordinates
      tr_colour Colour;        // Colour of the light
      
        uint8_t LightType;
        uint8_t Unknown;       // Always 0xFF?
        uint8_t Intensity;
        
          float In;            // Also called hotspot in TRLE manual
          float Out;           // Also called falloff in TRLE manual
          float Length;
          float CutOff;
          
          float dx, dy, dz;    // Direction - used only by sun and spot lights
};
----

[quote]**UNKNOWN** -- needs additional description!

`LightType` is somewhat similar to D3D light type, but there are some differences.

* *0* -- Sun
* *1* -- Light
* *2* -- Spot
* *3* -- Shadow
* *4* -- Fog bulb

[NOTE]
====
'Fog bulb' is a special case of room light, which actually don't work as usual light. It serves as a point in space, where a kind of 'volumetric fog' effect is generated. It works only if user has enabled corresponding option in game setup.

Fog bulbs don't use `Colour` field to define its colour. However, `Red` field of a `Colour` structure is used to define fog density. Colour itself can be only changed with special 'flipeffect #28' trigger function, which takes a value from the 'timer field' of the trigger to index into hardcoded RGB table of pre-defined colours. The table consists of 28 RGB values:
====

[width="75%",cols="^,^,^,^",align="center"]
|=====
| 0 = 0,0,0       | 7 = 0,64,192     | 14 = 111,255,223 | 21 = 0,30,016
| 1 = 245,200,60  | 8 = 0,128,0      | 15 = 244,216,152 | 22 = 250,222,167
| 2 = 120,196,112 | 9 = 150,172,157  | 16 = 248,192,60  | 23 = 218,175,117
| 3 = 202,204,230 | 10 = 128,128,128 | 17 = 252,0,0     | 24 = 225,191,78
| 4 = 128,64,0    | 11 = 204,163,123 | 18 = 198,95,87   | 25 = 77,140,141
| 5 = 64,64,64    | 12 = 177,162,140 | 19 = 226,151,118 | 26 = 4,181,154
| 6 = 243,232,236 | 13 = 0,223,191   | 20 = 248,235,206 | 27 = 255,174,0
|====
 
.TR5 Room Lighting

[source,cpp]
----
struct tr5_room_light   // 88 bytes
{
        float x, y, z;       // Position of light, in world coordinates
        float r, g, b;       // Colour of the light
        
       uint32_t Separator    // Dummy value = 0xCDCDCDCD (CD = Core Design?)
       
        float In;            // Cosine of the IN value for light / size of IN value
        float Out;           // Cosine of the OUT value for light / size of OUT value
        float RadIn;         // (IN radians) * 2
        float RadOut;        // (OUT radians) * 2
        float Range;         // Range of light
        
        float dx, dy, dz;    // Direction - used only by sun and spot lights
      int32_t x2, y2, z2;    // Same as position, only in integer.
      int32_t dx2, dy2, dz2; // Same as direction, only in integer.
      
      uint8_t LightType;
      
      uint8_t Filler[3];     // Dummy values = 3 x 0xCD
};
----

[quote]**UNKNOWN** -- needs additional description!

`x,y,z` values shouldn't be used by sun type light, but sun seems to have a large `x` value (9 million, give or take), a zero `y` value, and a small `z` value (4..20) in the original TR5 levels.

`In` and `Out` values aren't used by 'sun' type. For the 'spot' type, these are the 'hotspot' and 'falloff angle' cosines. For the 'light' and 'shadow' types, these are the TR units for the 'hotspot / falloff' (1024 = 1 sector).

`RadIn`, `RadOut` and `Range` are only used by the 'spot' light type.

`dx`, `dy` and `dz` values are used only by the 'sun' and 'spot' type lights. They describe the directional vector of the light. This can be obtained by:

* if both `x` and `y` latexmath:[$\mathnormal{LightDirectionVectorX} = \cos(X) * \sin(Y)$]
* latexmath:[$\mathnormal{LightDirectionVectorY} = \sin(X)$]
* latexmath:[$\mathnormal{LightDirectionVectorZ} = \cos(X) * \cos(Y)$]

`x2`, `y2`, `z2`, `dx2`, `dy2` and `dz2` values repeat previous corresponding information in long data types instead of floats.

`Separator` and `Filler` value (0xCD) is very common in TR5 format, presumably it's a programmer's joke abbreviating studio's name (Core Design = CD).

Room Vertex structure
+++++++++++++++++++++

This defines the vertices within a room. As mentioned above, room lighting is internal vertex lighting, except for necessarily external sources like
flares, flame emitters and gunflashes. Room ambient lights and point sources are ignored.

As TR3 introduced colored lighting, room vertex structure drastically changed. It changed once again in TR5, when floating-point numbers were introduced. So we'll define vertex structure for TR1-2, TR3-4 and TR5 independently.

.TR1-2 Room Vertex structure

[[tr_room_vertex]]
[source,cpp]
----
struct tr_room_vertex  // 8 bytes
{
     tr_vertex Vertex;
       int16_t Lighting1;
};
----

`Vertex` is the coordinates of the vertex, relative to <<tr_room_info>> `x` and `z` values.

`Lighting1` ranges from 0 (bright) to 0x1FFF (dark). This value is ignored by TR2, and `Lighting2` is used instead with the same brightness range.

TR2 uses an extended version of the structure:

[[tr2_room_vertex]]
[source,cpp]
----
struct tr2_room_vertex  // 12 bytes
{
     tr_vertex Vertex;
       int16_t Lighting1;
      uint16_t Attributes; // A set of flags for special rendering effects (absent from TR1)
       int16_t Lighting2;  // Almost always equal to Lighting1 (absent from TR1)
};
----

`Attributes` field is a 'set of flags', and their meaning is:

* 'Bit 15:' When used in room filled with water, don't move the vertices of the room when viewed from above (normally, when viewed from above, the vertices of a room filled with water moves to 'simulate' the refraction of lights in water). Note that when viewed from inside the room filled with water, the vertices of the other rooms outside still moves.
* 'Bit 4:' Vertex is 'normal' (i.e. no effect) -- it seems that 0x0000 gives the same result.
* 'Bits 0-4' are only used together in combination with the `LightMode` field of the <<tr_room>> structure. See below.

`Lighting2` field is also absent from TR1.

.TR3-4 Room Vertex structure

[source,cpp]
----
struct tr3_room_vertex  // 12 bytes
{
     tr_vertex Vertex;
       int16_t Lighting1;  // Value is ignored!
      uint16_t Attributes; // A set of flags for special rendering effects
      uint16_t Colour;     // 15-bit colour 
};
----

`Lighting1` value is ignored by the engine, as now each vertex has its own defined 15-bit colour (see below).

`Attributes` bit flags were extended. Here is the list:

* 'Bit 15:' *TR3 ONLY:* Same meaning as in <<tr_room_vertex>>
* 'Bit 14:' Simulates caustics by constantly shifting vertex colour brightness. Used mainly in underwater rooms, but can be used in rooms without water. In TR2, there was a similar effect, but it was assigned for all vertices in any water room.
* 'Bit 13:' Water / quicksand surface movement. Brightness is also shifting, if this flag is set. But it's not the same type as with 'Bit 14', it's much less noticeable.
* 'Bit 4:' *TR3 ONLY:* Same meaning as in <<tr_room_vertex>>

`Colour` value specifies vertex colour in 15-bit format (each colour occupies 5 bits): 0x0[red]RRRRR[green]GGGGG[blue]BBBBB. Therefore, each colour value's maximum is '31'. You can use this code to get each colour:

* 'Red:' `((Colour & 0x7C00) >> 10)`
* 'Green:' `((Colour & 0x03E0) >> 5)`
* 'Blue:' `(Colour & 0x001F)`

.TR5 Room Vertex structure

In TR5, room vertex structure was almost completely changed. Coordinates were converted to floats, and normal was added:

[[tr5_room_vertex]]
[source,cpp]
----
struct tr5_room_vertex  // 28 bytes
{
    tr5_vertex Vertex;     // Vertex is now floating-point
    tr5_vertex Normal;
      uint32_t Colour;     // 32-bit colour 
};
----

[quote]**UNKNOWN** -- needs additional description!

There is no more `Attributes` field in room vertex structure for TR5.


Room Sprite structure
+++++++++++++++++++++

[source,cpp]
----
struct tr_room_sprite  // 4 bytes
{
    int16_t Vertex;       // Offset into vertex list
    int16_t Texture;      // Offset into sprite texture list
};
----

`Vertex` indicates an index into room vertex list (`Room.Vertices[room_sprite.Vertex]`), which acts as a point in space where to display a sprite.

`Texture` is an index into the sprite texture list.


Room Data structure
+++++++++++++++++++

This is the whole geometry of the ``room,'' including walls, floors, ceilings, and other embedded landscape. It 'does not' include objects that Lara can interact
with (keyholes, moveable blocks, moveable doors, etc.), neither does it include 'static meshes' (mentioned below in the next section).

The surfaces specified here are rendered surfaces.

[NOTE]
====
'This is not a ``real'' C/C++ structure, in that the arrays are sized by the `NumXXX` elements that precede them. Also <<tr_room_vertex>> could be replaced by any other version-specific room vertex type (`tr3_room_vertex`, etc.). '
====

[source,cpp]
----
virtual struct tr_room_data    // (variable length)
{
    int16_t NumVertices;                   // Number of vertices in the following list
    tr2_room_vertex Vertices[NumVertices]; // List of vertices (relative coordinates)
    
    int16_t NumRectangles;                 // Number of textured rectangles
    tr_face4 Rectangles[NumRectangles];   // List of textured rectangles
    
    int16_t NumTriangles;                  // Number of textured triangles
    tr_face3 Triangles[NumTriangles];     // List of textured triangles
    
    int16_t NumSprites;                    // Number of sprites
    tr2_room_sprite Sprites[NumSprites];   // List of sprites
};
----

Room Static Mesh structure
++++++++++++++++++++++++++

Positions and IDs of static meshes (e.g. skeletons, spiderwebs, furniture, trees). This is comparable to the <<tr2_item>> structure, except that static meshes have no animations and are confined to a single room.

.TR1 Room Static Mesh structure

[source,cpp]
----
struct tr_room_staticmesh  // 18 bytes
{
    uint32_t x, y, z;    // Absolute position in world coordinates
    uint16_t Rotation;
    uint16_t Intensity1;
    uint16_t MeshID;     // Which StaticMesh item to draw
};
----

`Intensity1` ranges from 0 (bright) to 0x1FFF (dark).

In `Rotation` field, high two bits (`0xC000`) indicate steps of 90 degrees (e.g. (Rotation >> 14) * 90). However, when parsing this value, no extra bitshifting is needed, as you can simply interpret it using this formula:

[source,cpp]
----
float Real_Rotation = (float)Rotation / 16384.0f * -90;
----

TR2 again uses an extended version:

[source,cpp]
----
struct tr_room_staticmesh  // 20 bytes
{
    uint32_t x, y, z;    // Absolute position in world coordinates
    uint16_t Rotation;
    uint16_t Intensity1;
    uint16_t Intensity2; // Absent in TR1
    uint16_t MeshID;     // Which StaticMesh item to draw
};
----

`Intensity2` is seemingly not used, as changing this value does nothing.

.TR3-5 Room Static Mesh structure

[source,cpp]
----
virtual struct tr3_room_staticmesh  // 20 bytes
{
    uint32_t x, y, z;    // Absolute position in world coordinates
    uint16_t Rotation;
    uint16_t Colour;     // 15-bit colour
    uint16_t Unused;     // Not used!
    uint16_t MeshID;     // Which StaticMesh item to draw
};
----

`Colour` value specifies vertex colour in 15-bit format (each colour occupies 5 bits): 0x0[red]RRRRR[green]GGGGG[blue]BBBBB. Therefore, each colour value's maximum is '31'. You can use this code to get each colour:

* 'Red:' `((Colour & 0x7C00) >> 10)`
* 'Green:' `((Colour & 0x03E0) >> 5)`
* 'Blue:' `(Colour & 0x001F)`

TR5-specific room structure changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In TR5 the room format was drastically changed. The room itself is made up of 'sections'. These sections encompass a 3x3 sector grid (actually 3069x3069 pixels). Historically, these sections are referred as 'layers', however, more proper name for them is 'volumes'. Layers are organized in a quadtree-like structure, and their purpose was presumably optimizing rendering by some kind of space partitioning and culling invisible volumes.

Another thing to note is that some 'rooms' in TR5 do not actually contain visible mesh data. If concerned, we will refer to these rooms as 'null rooms'.

TR5 Room Layer structure
^^^^^^^^^^^^^^^^^^^^^^^^

[source,cpp]
----
struct tr5_room_layer   // 56 bytes
{
    uint32_t NumLayerVertices;   // Number of vertices in this layer (4 bytes)
    uint16_t UnknownL1;
    uint16_t NumLayerRectangles; // Number of rectangles in this layer (2 bytes)
    uint16_t NumLayerTriangles;  // Number of triangles in this layer (2 bytes)
    uint16_t UnknownL2;
    
    uint16_t Filler;             // Always 0
    uint16_t Filler2;            // Always 0

    // The following 6 floats define the bounding box for the layer

    float    LayerBoundingBoxX1;
    float    LayerBoundingBoxY1;
    float    LayerBoundingBoxZ1;
    float    LayerBoundingBoxX2;
    float    LayerBoundingBoxY2;
    float    LayerBoundingBoxZ2;

    uint32_t Filler3;     // Always 0 (4 bytes)
    uint32_t UnknownL6;   // Unknown
    uint32_t UnknownL7;   // Unknown
    uint32_t UnknownL8;   // Always the same throughout the level.
}
----

`UnknownL2` appears to be the number of double sided textures in this layer, however is sometimes 1 off (2 bytes).

The whole Room structure
~~~~~~~~~~~~~~~~~~~~~~~~

Here's where all the room data come together. 

Room structure differs drastically across different game versions (especially in TR5). For this reason, we will define each version of Room structure independently, to avoid confusion. Also, version-specific fields will be described in each version's section in a ``backwards-compatible'' manner, while common fields with version-specific variations, such as `Flags`, will be described afterwards in separate section.

'These are not ``real'' C/C++ structures, in that the arrays are sized by the `NumXXX` elements that precede them.'

TR1 Room structure
^^^^^^^^^^^^^^^^^^

As it's stored in the file, the <<tr_room_info>> structure comes first, followed by a `uint32_t NumDataWords`, which specifies the number of 16-bit words to follow.  Those data words must be parsed in order to interpret and construct the variable-length arrays of vertices, meshes, doors, and sectors. Such setup is also applicable to all variations of room structures, 'except' `tr5_room`, which will be described independently.

[[tr_room]]
[source,cpp]
----
virtual struct tr_room  // (variable length)
{
    tr_room_info info;           // Where the room exists, in world coordinates
    
    uint32_t NumDataWords;       // Number of data words (uint16_t's)
    uint16_t Data[NumDataWords]; // The raw data from which the rest of this is derived
    
    tr_room_data RoomData;       // The room mesh
    
    uint16_t NumPortals;                 // Number of visibility portals to other rooms
    tr_room_portal Portals[NumPortals];  // List of visibility portals
    
    uint16_t NumZsectors;                                  // ``Width'' of sector list
    uint16_t NumXsectors;                                  // ``Height'' of sector list
    tr_room_sector SectorList[NumXsectors * NumZsectors];  // List of sectors in this room
    
    int16_t AmbientIntensity;
    
    uint16_t NumLights;                 // Number of lights in this room
    tr_room_light Lights[NumLights];    // List of lights
    
    uint16_t NumStaticMeshes;                            // Number of static meshes
    tr2_room_staticmesh StaticMeshes[NumStaticMeshes];   // List of static meshes
    
    int16_t AlternateRoom;
    int16_t Flags;
};
----

`AmbientIntensity` is a brightness value which affects only 'externally-lit' objects. It ranges from 0 (bright) to 0x1FFF (dark).

`AlternateRoom` (or, as it is called in TRLE terms, 'flipped room') is the number of the room that this room can 'flip' with. In the terms of the gameplay, 'flipped' room is a state change of the same room -- for example, empty or flooded with water, filled with sand or debris. Alternate room usually has the same boundaries as original room, but altered geometry and/or texturing. Detailed description of 'alternate rooms' will be provided in a separate section.

TR2 Room structure
^^^^^^^^^^^^^^^^^^

[source,cpp]
----
virtual struct tr2_room  // (variable length)
{
    tr_room_info info;           // Where the room exists, in world coordinates
    
    uint32_t NumDataWords;       // Number of data words (uint16_t's)
    uint16_t Data[NumDataWords]; // The raw data from which the rest of this is derived
    
    tr_room_data RoomData;       // The room mesh
    
    uint16_t NumPortals;                 // Number of visibility portals to other rooms
    tr_room_portal Portals[NumPortals];  // List of visibility portals
    
    uint16_t NumZsectors;                                  // ``Width'' of sector list
    uint16_t NumXsectors;                                  // ``Height'' of sector list
    tr_room_sector SectorList[NumXsectors * NumZsectors];  // List of sectors in this room
    
    int16_t AmbientIntensity;
    int16_t AmbientIntensity2;  // Usually the same as AmbientIntensity
    int16_t LightMode;
    
    uint16_t NumLights;                 // Number of point lights in this room
    tr_room_light Lights[NumLights];    // List of point lights
    
    uint16_t NumStaticMeshes;                            // Number of static meshes
    tr_room_staticmesh StaticMeshes[NumStaticMeshes];   // List of static meshes
    
    int16_t AlternateRoom;
    int16_t Flags;
};
----

`AmbientIntensity2` value is usually equal to `AmbientIntensity` value. Seems it's not used.

`LightMode` specifies lighting mode special effect, which is applied to all room vertices 'in conjunction with 5 lowest bits of `Attributes` field belonging to <<tr_room_vertex>> structure. Here we will refer these 5 bits' value to as 'effect_value:'

* *0* -- Normal lighting mode, no special effects.
* *2* -- If 'effect_value' is in 0-15 range, then vertex lighting is cyclically fading to more bright value. The lower the value is, the deeper the fade to full vertex lighting is. If 'effect_value' is in 17-30 range ('not' 31!), then vertex lighting is cyclically fading to more dark value. The higher the value is, the deeper the fade to black is. If 'effect_value' is 16, no effect is produced. So practically, 'effect_value' serves as a multiplier to overall effect brightness.
* *1* -- Produces flickering effect, with 'effect_value' acting the same way -- as intensity multiplier.


TR3 Room Structure
^^^^^^^^^^^^^^^^^^

[source,cpp]
----
virtual struct tr3_room  // (variable length)
{
    tr_room_info info;           // Where the room exists, in world coordinates
    
    uint32_t NumDataWords;       // Number of data words (uint16_t's)
    uint16_t Data[NumDataWords]; // The raw data from which the rest of this is derived
    
    tr_room_data RoomData;       // The room mesh
    
    uint16_t NumPortals;                 // Number of visibility portals to other rooms
    tr_room_portal Portals[NumPortals];  // List of visibility portals
    
    uint16_t NumZsectors;                                  // ``Width'' of sector list
    uint16_t NumXsectors;                                  // ``Height'' of sector list
    tr_room_sector SectorList[NumXsectors * NumZsectors];  // List of sectors in this room
    
    int16_t AmbientIntensity1;  // This and the next one only affect externally-lit objects
    int16_t AmbientIntensity2;  // Usually the same as AmbientIntensity1
    
    uint16_t NumLights;                 // Number of point lights in this room
    tr3_room_light Lights[NumLights];   // List of point lights
    
    uint16_t NumStaticMeshes;                            // Number of static meshes
    tr_room_staticmesh StaticMeshes[NumStaticMeshes];    // List of static meshes
    
    int16_t AlternateRoom;
    int16_t Flags;
    
    uint8_t WaterScheme;
    uint8_t ReverbInfo;
    
    uint8_t Filler;  // Unused.
};
----

TR4 Room Structure
^^^^^^^^^^^^^^^^^^

[source,cpp]
----
virtual struct tr4_room  // (variable length)
{
    tr_room_info info;           // Where the room exists, in world coordinates
    
    uint32_t NumDataWords;       // Number of data words (uint16_t's)
    uint16_t Data[NumDataWords]; // The raw data from which the rest of this is derived
    
    tr_room_data RoomData;       // The room mesh
    
    uint16_t NumPortals;                 // Number of visibility portals to other rooms
    tr_room_portal Portals[NumPortals];  // List of visibility portals
    
    uint16_t NumZsectors;                                  // ``Width'' of sector list
    uint16_t NumXsectors;                                  // ``Height'' of sector list
    tr2_room_sector SectorList[NumXsectors * NumZsectors]; // List of sectors in this room
    
    uint32_t RoomColour;        // In ARGB format!
    
    int16_t AmbientIntensity1;  // This and the next one only affect externally-lit objects
    int16_t AmbientIntensity2;  // Usually the same as AmbientIntensity1
    
    uint16_t NumLights;                 // Number of point lights in this room
    tr4_room_light Lights[NumLights];   // List of point lights
    
    uint16_t NumStaticMeshes;                           // Number of static meshes
    tr_room_staticmesh StaticMeshes[NumStaticMeshes];   // List of static meshes
    
    int16_t AlternateRoom;
    int16_t Flags;
    
    uint8_t WaterScheme;
    uint8_t ReverbInfo;
    
    uint8_t AlternateGroup;  // Replaces Filler from TR3
};
----

`RoomColour` replaces `AmbientIntensity` and `AmbientIntensity2` values from `tr2_room` structure. Note it's 'not in `tr_colour4` format', because colour order is reversed. It should be treated as ARGB, where A is unused.

`AlternateGroup` was introduced in TR4 to solve long-existing engine limitation, which flipped 'all alternate rooms at once' (see 'flipmap' trigger function description in <<trigger-functions,Trigger Functions>> section). Since TR4, engine only flips rooms which have similar index in room's `AlternateGroup` field and trigger operand.

TR5 Room Structure
^^^^^^^^^^^^^^^^^^

[NOTE]
====
As it was mentioned before, TR5 room structure was almost completely changed, when compared to previous versions. For example, TR5 completely throws out a concept of `tr_room_data` structure, shuffles numerous values and structures in almost chaotic manner, and introduces a bunch of completely new parameters (mostly to deal with 'layers'). Also, there is vast amount of 'fillers' and 'separators', which contain no specific data.

The one possible reason for such ridiculous structure change is an attempt to 'crypt file format', so it won't be accessed by unofficial level editing tools, which received major development by that time. Another possible reason is whole TR5 development process was rushed, as the team developed 'Tomb Raider: Angel of Darkness' at the very same time.
====

[source,cpp]
----
virtual struct tr5_room // (variable length)
{
    char XELA[4];           // So-called "XELA landmark"
 
    uint32_t RoomDataSize;
    
    uint32_t Seperator;     // 0xCDCDCDCD (4 bytes)

    uint32_t EndSDOffset;
    uint32_t StartSDOffset;

    uint32_t Separator;     // Either 0 or 0xCDCDCDCD

    uint32_t EndPortalOffset;
    
    tr_room_info info;

    uint16_t NumZSectors;
    uint16_t NumXSectors;

    uint32_t RoomColour;   // In ARGB format!

    uint16_t NumLights;
    uint16_t NumStaticMeshes;

    uint8_t  ReverbInfo;
    uint8_t  AlternateGroup;
    uint16_t WaterScheme;

    uint32_t Filler[2];    // Both always 0x00007FFF
    uint32_t Separator[2]; // Both always 0xCDCDCDCD
    uint32_t Filler;       // Always 0xFFFFFFFF

    uint16_t AlternateRoom;
    uint16_t Flags;

    uint32_t Unknown1;
    uint32_t Unknown2;     // Always 0
    uint32_t Unknown3;     // Always 0
        
    uint32_t Separator;    // 0xCDCDCDCD

    uint16_t Unknown4;
    uint16_t Unknown5;

    float RoomX;
    float RoomY;
    float RoomZ;

    uint32_t Separator[4]; // Always 0xCDCDCDCD
    uint32_t Separator;    // 0 for normal rooms and 0xCDCDCDCD for null rooms
    uint32_t Separator;    // Always 0xCDCDCDCD

    uint32_t NumRoomTriangles;
    uint32_t NumRoomRectangles;

    uint32_t Separator;     // Always 0

    uint32_t LightDataSize;
    uint32_t NumLights2;    // Always same as NumLights

    uint32_t Unknown6;

    int32_t RoomYTop;
    int32_t RoomYBottom;

    uint32_t NumLayers;
        
    uint32_t LayerOffset;
    uint32_t VerticesOffset;
    uint32_t PolyOffset;
    uint32_t PolyOffset2;   // Same as PolyOffset

    uint32_t NumVertices;

    uint32_t Separator[4];  // Always 0xCDCDCDCD

    tr5_room_light Lights[NumLights];    // Data for the lights (88 bytes * NumRoomLights)
    tr2_room_sector SectorList[NumXSectors * NumZSectors]; // List of sectors in this room

    uint16_t NumPortals;                 // Number of visibility portals to other rooms
    tr_room_portal Portals[NumPortals];  // List of visibility portals

    uint16_t Separator;  // Always 0xCDCD

    tr3_room_staticmesh StaticMeshes[NumStaticMeshes];   // List of static meshes

    tr5_room_layer[NumLayers]; // Data for the room layers (volumes) (56 bytes * NumLayers)

    uint8_t Faces[(NumRoomRectangles * sizeof(tr_face4) + NumRoomTriangles * (tr_face3)];

    tr5_room_vertex Vertices[NumVertices];
}
----

`XELA` landmark seemingly serves as a header for room structure. It is clear that 'XELA' is a reversed 'ALEX', which is most likely the name of TR5 programmer, 'Alex Davis'. It probably indicates that Alex Davis is responsible for changes in room structures.

`RoomDataSize` is a handy value determining the size of the following data. You can use this value to quickly 'parse thru' to the next room.

`EndSDOffset`: usually this number `+ 216` will give you the offset from the start of the room data to the end of the `SectorData` section. However, it is known that this uint32_t could be equal to `0xFFFFFFFF`, so to calculate the end of `SectorData`, it is better to use the following value `StartSDOffset + 216 + ((NumXSectors * NumZSectors)*8)`, if you need to obtain this information.

`StartSDOffset`: This number `+ 216` will give you the offset from the start of the room to the start of the `SectorData` section.

`EndPortalOffset`: this number `+ 216` will give you the offset from the start of the room to the end of the portal data.

`RoomX`, `RoomY` and `RoomZ` values are positions of room in world coordinates. *NOTE:* If room is 'null room', then each of these values will be `0xCDCDCDCD`.

`NumRoomTriangles` and `NumRoomRectangles` are respectively the numbers of triangular and rectangular faces in a given room. *NOTE:* If room is 'null room', each of these values will be `0xCDCDCDCD`.

`LightDataSize` is the size of the light data in bytes ('not' in `tr5_room_light` units).

`Unknown6` could probably be a copy of `ReverbInfo` (see further), as its value usually ranges from 0 to 3.

`RoomYTop` and `RoomYBottom` are equal to `yTop` and `yBottom` values in <<tr_room_info>> structure. If room is a 'null room', both of these values are `0xCDCDCDCD`.

`NumLayers` is a number of layers (volumes) in this room.

`LayerOffset`: this number `+ 216` will give you an offset from the start of the room data to the start of the layer data.

`VerticesOffset`: this number `+ 216` will give you an offset from the start of the room data to the start of the verex data.

`PolyOffset`: this number `+ 216` will give you an offset from the start of the room data to the start of the rectangle/triangle data.

`VerticesSize` is the size of vertex data block in bytes. Therefore, it 'must' be a multiple of `tr5_room_vertex` size, else it means the block size is wrong.

`Faces` is a sequential data array for the room polygons (both `tr_face4` and `tr_face3`), 

[NOTE]
====
`Faces` array is strictly linked with `NumLayers` value. The data is sequentially structured for each layer -- at first it lists first layer's rectangles then triangles, followed by the second layer's rectangles and triangles, and so on, until all layers are done.
====

Common fields of a room structure
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`Flags` is an array of various flag bits, which meaning is as follows:

* 'Bit 0' -- Room is filled with water.
* 'Bit 3' -- *ONLY IN TR2-5:* Set if the 'skybox' can be seen from this room. Used to speed things up: if no rendered room has this bit set, then the sky can never been seen, so it is not rendered. Else, if at least one visible room has this bit set, then the sky must be drawn because it is (could be) visible.
* 'Bit 5' -- *ONLY IN TR2-5:* Lara's ponytail gets blown by the wind. Beginning with TR3, some particle types are also be blown, if they end up in such room (particle type is specified by certain particle flag).
* 'Bit 6' -- *ONLY IN TR3-5:* Unknown. A lot of rooms have this bit set but it seems it does nothing...
* 'Bit 7' -- *ONLY IN TR3-5:* Different meaning in TR3 and TR4/5. In TR3, it means that room is filled with quicksand, while in TR4/5 it presumably blocks 'global lens flare' from appearing in that room (in TRLE, checkbox which sets this flag is named 'NL').
* 'Bit 8' -- In TR1, the meaning is unknown. In TR3-5, it is presumably 'mist room'. TRLE sets this bit when the M ('mist') option is used (in the same time, the amount of mist typed by the user is put in the `water_scheme` byte). Unknown effect on the rendering / the game -- probably, the feature was never implemented in final version.
* 'Bit 9' -- *ONLY IN TR3-5:* The room has some 'water reflectivity'. TRLE sets this bit when the R ('reflectivity') option is used (in the same time, the amount of reflectivity typed by the user + 5 is put in the `water_scheme` byte). When the flag is set for normal room and there is water room below it, game engine creates ``reflection effect'' above the water surface -- effectively it means that all the vertices at the bottom of the room receive caustics effect described well above.
* 'Bit 11' -- Not found in any original TR levels, but when the 'D' flag is set in the TRLE, this bit is set. Was re-used in NGLE as a flag specifying 'Damage room'.
* 'Bit 12' -- Not found in any original TR levels, but when the 'P' flag is set in the TRLE, this bit is set. Was also re-used in NGLE as a flag specifying 'Poisonous room'.

*ONLY IN TR3-5:* `WaterScheme` is used for different purposes. If room is a water room, then it specifies underwater caustics patterns (maximum value is 15). If it is set for normal room 'placed above the water room', then it controls 'wave strength' effect applied to the faces adjoining water room -- but only if there is a special light, which radius reaches the vertices of this particular room.

*ONLY IN TR3-5:* `ReverbInfo` defines 'room reverberation type'. It affects sound postprocessing, if listener position belongs to that room. This feature was present 'only in PlayStation versions' of the game, but not on PC. Nevertheless, the info is preserved in PC level files. Here are the types of reverberation:

* *0* -- Outside. No (or barely heard) reverberation.
* *1* -- Small room. Little reverberation.
* *2* -- Medium room.
* *3* -- Large room.
* *4* -- Pipe. Highest reverberation level. Almost never used.

[big red]*Old TRosettaStone text ahead -- current progress is above this bookmark.*

[[FloorData]]
FloorData
---------

The 'FloorData' defines special sector attributes such as floor and ceiling slopes, collisional portals to other rooms, climbability of walls, and all the
various types of triggering. It is referenced by the sectors as an array of 16-bit unsigned integers, e.g. the current sector is calculated as `(((CurrentX -
tr2_room_info.x) / 1024) * tr2_room.NumZsectors) + ((CurrentZ - tr2_room_info.z) / 1024)`, which is then used as an offset into `tr2_room::SectorList[]`;
`tr2_room_sector::FDindex` is an offset into the `FloorData[]` array.

The FloorData consists of opcodes and operands.  Opcodes are 16 bits, as follows:
[width="20%",cols="1,2"]
|=====
| `Function`    | bits 0..7 (`0x00FF`)
| `SubFunction` | bits 8..14 (`0x7F00`)
| `EndData`     | bit 15 (`0x8000`)
|====

If `EndData` is set, there are no more opcodes (after the current one) in this section of `FloorData`;  otherwise, the next opcode in `FloorData` should be
interpreted after the current one.

Some functions reference an `FDlist`, which is a separate list of opcodes and operands that immediately follows the current `FloorData` opcode.  `FDlist` opcodes
and operands are different from the base `FloorData` opcodes and operands:
[width="40%",cols="1,5"]
|====
| `FDfunction`  | bits 10-13 (`0x3C00`)
| `Operands`    | bits 0-9 (`0x03FF`) vary, depending on `FDfunction`
| `FDcontinue`  | bit 15 (`0x8000`)
|====

Several of the functions indicate adjustments to the sector's floor and ceiling heights; these are specified by adjusting the corner heights. The corners will
be denoted as `00`, `01`, `10`, and `11`; the first is the corner's X coordinate and the second is the corner's Z coordinate, with both given as multiples of 1024.

[NOTE]
====
[green]#When parsing functions for TR3, use only the lower 5 bits to find the function value, because some of TR3's functions use the upper 3 bits of the lower byte as
part of the operand. However, this will also work correctly in TR1 and TR2.#
====

FloorData Functions
~~~~~~~~~~~~~~~~~~~

.Function `0x01` -- Portal Sector
* SubFunction `0x00` -- Room Portal +
  The next `FloorData` element (the operand) is the number of the room that this sector is a collisional portal to.
  An entity that arrives in a sector with this function present will gets its room membership changed to this function's operand, without any change in
  position.

.Function `0x02` -- Floor Slant
* SubFunction `0x00` -- Floor Slant +
  The next FloorData element contains the slant values for the floor of this sector.  Slant values are specified in
  increments of 256 units. The high byte (`int8_t`) is the Z slope, while the low byte (`int8_t`) is the X slope. If the X slope is greater than zero, then its value is
  added to the floor heights of corners `00` and `01`. If it is less than zero, then its value is subtracted from the floor heights of corners `10` and `11`. If the Z
  slope is greater than zero, then its value is added to the floor heights of corners `00` and `10`. If it is less than zero, then its value is subtracted from the
  floor heights of corners `01` and `11`.

.Function `0x03` -- Ceiling Slant
* SubFunction `0x00` -- Ceiling Slant +
  The next `FloorData` element contains the slant values for the ceiling of this sector.  Slant values are specified in
  increments of 256 units. The high byte (`int8_t`) is the Z slope, while the low byte (`int8_t`) is the X slope. If the X slope is greater than zero, then its value is
  subtracted from the ceiling heights of corners `10` and `11`. If it is less than zero, then its value is added to the ceiling heights of corners `00` and `01`. If the Z
  slope is greater than zero, then its value is subtracted from the ceiling heights of corners `00` and `10`. If it is less than zero, then its value is added to the
  ceiling heights of corners `01` and `11`.

.Function `0x04` -- Trigger items, switch cameras, end the level and much more. +
As used below, ``run FDlist(activate or deactivate)'' means go through each element in `FDlist` and perform its function (``run FDlist+1'' just means start at
`FDlist[1]` rather than `FDlist[0]`).  Activate/deactivate is only used for the activate/deactivate item function.
There are two states for each item, active/inactive (the meaning depends on the item, e.g. a tiger must be active to be seen, if a door is active it is open, if
it is inactive it is closed, etc.) and on/off (keyholes and switches).
The `uint16_t` immediately following the `0x04 FloorData` opcode contains flags; the bits at `0x3e00` are the Activation Mask (which is XORed with any appropriate
item flags), the bit at `0x0100` indicates ``state change occurs only once''. A good example of activation-mask use is the multiple-switch room of ``Palace
Midas'' in TR1.

* SubFunction `0x00` -- Run FDlist(activate)
* SubFunction `0x01` -- If Lara is on the ground, run FDlist(activate)
* SubFunction `0x02` -- If item at FDlist[0] is on, run FDlist+1(activate), else run FDlist+1(deactivate)
* SubFunction `0x03` -- If item at FDlist[0] is on, run FDlist+1(activate)
* SubFunction `0x04` -- If item at FDlist[0] is picked up, run FDlist+1(activate)
* SubFunction `0x05` -- If item at FDlist[0] is in this sector, run FDlist+1(activate), else run FDlist+1(deactivate)
* SubFunction `0x06` -- If Lara is on the ground, run FDlist(deactivate)
* SubFunction `0x07` -- _unknown_
* SubFunction `0x08` -- If Lara is not on the ground, run FDlist(activate) (mainly used for activating collision detection with such objects as footbridges)
* SubFunction `0x09` -- Run FDlist(deactivate)

.Function `0x05` -- Kills Lara
Any SubFunction: If Lara is on the ground, it kills Lara with fire.

.Function `0x06` -- Climbable Walls
This subfunction indicates climbability of walls; its value is the bitwise OR of the values associated with all the climbable-wall directions (`0x01` ::=
+Z, `0x02` ::= +X, `0x04` ::= -Z, `0x08` ::= -X), e.g. SubFunction `0x09` indicates that the walls on both the +Z and -X sides of this sector are climbable.

[NOTE]
[green]#The following functions are only relevant for TR3, this *all these functions are virtually colored green*.#

.Functions `0x07` to `0x12` (only in TR3)
These specify the floor and ceiling slopes, which are more complicated here, since these functions specify dividing
up the floors and ceilings into triangles along either of the two diagonals. Also, one of the triangles may be a collisional portal to the room above (if in the
ceiling) or to the room below (if in the floor). The function word must be parsed as follows:

[width="40%",cols="1,2"]
|====
| Bit 15     | Continuation bit
| Bits 10-14 | value `t01`
| Bits 5-9   | value `t00`
| Bits 0-4   | function value
|====
where t00 and t01 are signed.

It is followed by one operand, to be parsed as follows:
[width="30%"]
|====
| Bits 12-15 | value `t13`
| Bits 8-11  | value `t12`
| Bits 4-7   | value `t11`
| Bits 0-3   | value `t10`
|====
where `t10`, `t11`, `t12`, and `t13` are unsigned.


Here are the triangulations and vertex adjustments; for some of the functions, one of the triangles is a portal to another room:

.Functions `0x07`, `0x0b`, `0x0c`
* Triangle 1 -- `00`-`01`-`10` (function `0x0b`: is a portal)
* Triangle 2 -- `11`-`10`-`01` (function `0x0c`: is a portal)

Overall adjustment: `adj = t00 + t01 + t10 + t12`

Add these quantities to these vertex floor heights:

* `00` -- `(adj - t11)`
* `01` -- `(adj - t12)`
* `10` -- `(adj - t10)`
* `11` -- `(adj - t13)`

.Functions `0x08`, `0x0d`, `0x0e`
* Triangle 1 -- `01`-`11`-`00` (function `0x0d`: is a portal)  +
* Triangle 2 -- `10`-`00`-`11` (function `0x0e`: is a portal)

Overall adjustment: adj = t00 + t01 + t11 + t13

Add these quantities to these vertex floor heights:

* `00` -- `(adj - t11)`
* `01` -- `(adj - t12)`
* `10` -- `(adj - t10)`
* `11` -- `(adj - t13)`

.Functions `0x09`, `0x0f`, `0x10`
* Triangle 1 -- `00`-`10`-`01` (function `0x0f`: is a portal)
* Triangle 2 -- `11`-`01`-`10` (function `0x10`: is a portal)

Overall adjustment: `adj = t10 + t12`

Subtract these quantities from these vertex ceiling heights:

* `00` -- `(adj - t12)`
* `01` -- `(adj - t11)`
* `10` -- `(adj - t13)`
* `11` -- `(adj - t10)`

.Functions `0x0a`, `0x10`, `0x11`
* Triangle 1 -- `01`-`00`-`11` (function `0x11`: is a portal)
* Triangle 2 -- `10`-`11`-`00` (function `0x12`: is a portal)

Overall adjustment: `adj = t11 + t13`

Subtract these quantities from these vertex ceiling heights:

* `00` -- `(adj - t12)`
* `01` -- `(adj - t11)`
* `10` -- `(adj - t13)`
* `11` -- `(adj - t10)`
 

.Function `0x13`
Has subfunction 0x00 and no operand. Unknown, but is possibly monkey-swingability of the ceiling.

[[trigger-functions]]
Trigger functions
~~~~~~~~~~~~~~~~~

.FDfunction `0x00` -- Activate or deactivate item
* Operand (bits 0..9) -- Item index

.FDfunction `0x01` -- Switch to camera
(also uses the `uint16_t` immediately following)

* Operand (bits 0..6) -- Index in `Cameras[]` +
  The `uint16_t` immediately following _specifies delay and repeatability for switched camera_.
* Operand (bits 0..7 (`0xff`)) -- Camera Delay +
  Number of seconds to wait before automatically switching back to the normal camera.
  `0x00` never switches back to the normal camera.
* Operand (bit 8 (`0x100`)) -- If set, only switch to camera once; otherwise, switch to camera every time

.FDfunction `0x02` -- Underwater Current
* Operand (bits 0..9 (`0x3ff`)) -- direction and intensity of flow
  ** 0, 1, 2 -- -Z direction in decreasing intensity (0 is strongest)
  ** 3, 4, 5 -- -X direction in decreasing intensity
  ** 6, 7, 8 -- +Z direction in decreasing intensity
  ** 9, 10, 11 -- +X direction in decreasing intensity

.FDfunction `0x03` -- Set AlternateRoom Variable
* Operand (bit 0 (`0x01`)) -- AlternateRoom Flag value (0/1)

.FDfunction `0x04` -- Alter Room Flags
This affects (enhances/negates) roomflags (always paired with `0x05`)

* Operand -- not sure, range 0-5

.FDfunction `0x05` -- Alter Room Flags
This affects (enhances/negates) roomflags (always paired with `0x04`)

* Operand -- not sure, range 0-5

.FDfunction `0x06` -- Look at Item
(if a camera change is also desired, this should come first)

* Operand (bits 0..9 (`0x3ff`)) -- Item index

.FDfunction `0x07` -- End Level

.FDfunction `0x08` -- Play CD Track
* Operand (bits 0..9 (`0x3ff`)) -- CD track ID (TR1: Internal Sound Index)

.FDfunction `0x09` -- Assault Course Clock Control
* Operand (bits 0..9 (`0x3ff`))
  ** `0x1c` ::= clear clock
  ** `0x1d` ::= stop clock
  ** `0x1e` ::= clock reset and displayed +
     This opcode is also associated with switches; other values of its operand appear to indicate switch sounds.

.FDfunction `0x0a` -- Play ``Found Secret'' Sound
* Operand (bits 0..9 (`0x3ff`))  Which secret (0..NumSecrets-1)

.FDfunction `0x0b` -- Unknown

While `FloorData` index 0 means the sector does not use floordata, there is still a ``dummy'' entry for index 0.  This dummy entry doesn't contain any useful
information.

Mesh Geometry
-------------

Overview
~~~~~~~~

Nearly all of the non-geographic visual elements in TR2 (as well as a few parts of the landscape) are specified as _meshes_.  A _mesh_ is simply a
list of vertices and how they're arranged.  The TR2 mesh structure includes a list of vertices as relative coordinates (which allows meshes to easily be placed
anywhere in the world geometry), a list of normals (to indicate which side of each face is visible), and lists of Rectangles and Triangles, both Textured and
Coloured.  The elements of each <<tr_face4>> or <<tr_face3>> structure (Rectangles and Triangles) contain an offset
into the `Vertices[]` array for the mesh. Other arrays (`Moveables[]`, `StaticMeshes[]`) do not reference the array `Meshes[]` directly, but instead reference the array
`MeshPointers[]`, which points to locations inside of `Meshes[]`, inside of which the meshes are stored in packed fashion.

Meshes
~~~~~~

The sign of the number of normals specifies which sort of lighting to use. If the sign is positive, then external vertex lighting is used, with the
lighting calculated from the room's ambient and point-source lighting values. The latter appears to use a simple Lambert law for directionality: intensity is
proportional to latexmath:[$\max(\langle (\mathrm{normal direction}), (\mathrm{direction to source}) \rangle, 0)$]. If the sign is negative, then internal vertex lighting is used, using the data included with
the mesh.

[CAUTION]
====
This is not a ``real'' C/C++ structure, in that the arrays are sized by the `NumXXX` elements that precede them.
====

[source,cpp]
----
virtual struct tr2_mesh
{
    tr2_vertex Centre; // This is usually close to the mesh's centroid, and appears to be the center of a sphere used for collision testing.
    int32_t CollisionSize; // This appears to be the radius of that aforementioned collisional sphere.
    int16_t NumVertices; // number of vertices in this mesh
    tr2_vertex Vertices[NumVertices]; // list of vertices (relative coordinates)
    int16_t NumNormals; // If positive, number of normals in this mesh.
                                    // If negative, number of vertex lighting elements (* (-1))
    tr2_vertex Normals[NumNormals]; // list of normals (if NumNormals is positive)
    int16_t Lights[-NumNormals]; // list of light values (if NumNormals is negative)
    int16_t NumTexturedRectangles; // number of textured rectangles in this mesh
    tr_face4 TexturedRectangles[NumTexturedRectangles]; // list of textured rectangles
    int16_t NumTexturedTriangles; // number of textured triangles in this mesh
    tr_face3 TexturedTriangles[NumTexturedTriangles]; // list of textured triangles
    int16_t NumColouredRectangles; // number of coloured rectangles in this mesh
    tr_face4 ColouredRectangles[NumColouredRectangles]; // list of coloured rectangles
    int16_t NumColouredTriangles; // number of coloured triangles in this mesh
    tr_face3 ColouredTriangles[NumColouredTriangles]; // list of coloured triangles
};
----
 

Static Meshes
~~~~~~~~~~~~~

[source,cpp]
----
/*
 * StaticMesh structure. This defines meshes that don't move (e.g. skeletons
 * lying on the floor, spiderwebs, trees, statues, etc.)
 * StaticMeshes have two bounding boxes; it is not clear why they have more than
 * one. One could be the visibililty box, and one could be the collisional
 * box, for instance; the former being used for visibility testing, and the
 * latter for collision testing.
 */
struct tr2_staticmesh
{
    // 32 bytes
    uint32_t ObjectID; // Object Identifier (matched in Items[])
    uint16_t Mesh; // mesh (offset into MeshPointers[])
    tr2_vertex BoundingBox[2][2]; // First index is which one; second index is opposite corners
    uint16_t Flags; // Meaning uncertain; it is usually 2, and is 3 for objects Lara can travel through,
                      // like TR2's skeletons and underwater vegetation
};
----

Moveables
~~~~~~~~~

[source,cpp]
----
/*
 * Moveable structure. This defines a list of contiguous meshes that
 * comprise one object.
 * This structure also points to the hierarchy and offsets of the meshes
 * (MeshTree), and also to the animations used (Animation); these will be
 * described in detail below. If the Animation index is -1, that means that
 * the entity's animations are all generated by the engine; an example is
 * Lara's ponytail. Some movables are really stationary, such as locks and
 * the sky, and some are not rendered, such as ``look at me'' points to aim
 * the camera at.
 */
struct tr2_moveable
{
    // 18 bytes
    uint32_t ObjectID; // Item Identifier (matched in Items[])
    uint16_t NumMeshes; // number of meshes in this object
    uint16_t StartingMesh; // stating mesh (offset into MeshPointers[])
    uint32_t MeshTree; // offset into MeshTree[]
    uint32_t FrameOffset; // byte offset into Frames[] (divide by 2 for Frames[i])
    uint16_t Animation; // offset into Animations[]
};
----

 
Items
~~~~~

Items are instances of objects, which can be sprite sequences or movables. For an object to appear in a level, it must be referenced in the `Items[]`
array. Multiple instances are possible (e.g. two identical tigers in different rooms are represented using two entries in `Items[]`, one for each). The object ID
is used to locate the appropriate sprite sequence or movable for the item.

[[tr2_item]]
[source,cpp]
----
struct tr2_item
{
    // 24 bytes [TR1: 22 bytes]
    int16_t ObjectID; // Object Identifier (matched in Moveables[], or SpriteSequences[], as appropriate)
    int16_t Room; // which room contains this item
    int32_t x; // item position in world coordinates
    int32_t y;
    int32_t z;
    int16_t Angle; // ((0xc000 >> 14) * 90) degrees
    int16_t Intensity1; // (constant lighting; -1 means use mesh lighting)
    int16_t Intensity2; // Like Intensity1, and almost always with the same value. [absent from TR1 data files]
    uint16_t Flags; // 0x0100 indicates ``initially invisible'', 0x3e00 is Activation Mask
                            // 0x3e00 indicates ``open'' or ``activated'';  these can be XORed with
                           // related FloorData::FDlist fields (e.g. for switches)
};
----

Sprites
~~~~~~~

These are ``billboard'' objects that are always rendered perpendicular to the view direction. These are used for text and explosion effects and similar things;
they are also used for some scenery objects and pickup items, though this use gets less as one goes from TR1 to TR3. The various ``Sides'' below are the
positions of the sprite sides relative to the sprite's overall position, measured in TR's world-coordinate units.

[source,cpp]
----
struct tr2_sprite_texture
{
    // 16 bytes
    uint16_t Tile;
    uint8_t x;
    uint8_t y;
    uint16_t Width;        // actually (Width * 256) + 255
    uint16_t Height;       // actually (Height * 256) + 255
    int16_t LeftSide;
    int16_t TopSide;
    int16_t RightSide;
    int16_t BottomSide;
};
----
 

Sprite Sequences
~~~~~~~~~~~~~~~~

These are collections of sprites that are referred to as a group. The members of this group can be cycled through (animated sprites such as flames) or selected
in other ways (text). Some sequences have only one member; this is done so as to access all the sprites in the same way.

[source,cpp]
----
struct tr2_sprite_sequence
{
    // 8 bytes
    int32_t ObjectID; // Item identifier (matched in Items[])
    int16_t NegativeLength; // negative of ``how many sprites are in this sequence''
    int16_t Offset; // where (in sprite texture list) this sequence starts
};
----

Mesh Construction and Animation
-------------------------------

Overview
~~~~~~~~

The animated mesh objects in the Tomb Raider series are sets of meshes that are moved relative to each other, as defined by `Moveables[]` entries. Each entry
describes which meshes to be used (a contiguous set of them referred to in `MeshPointers[]`), what hierarchy and relative offsets they have (contents of
`MeshTree[]` pointed to), and what animations are to be used (contents of `Animations[]` pointed to).

The hierarchy used is a branching one, with the meshes being at the nodes, and with the first mesh being the root node. The `MeshTree[]` values, called ``Bone2''
in some documentation, are applied to each of the child meshes in sequence; they are sets of four `int32_t`'s, the first being a hierarchy
operator, and the remaining three being the coordinates in the parent mesh's system. A hierarchy example is that for the Lara meshes:

* Hips
** Left thigh
*** Left shin
**** Left foot
** Right thigh
*** Right shin
**** Right foot
** Torso
*** Left inner arm
**** Left outer arm
***** Left hand
*** Right inner arm
**** Right outer arm
***** Right hand
*** Head

(Ponytail is a separate object)


This is implemented by using a stack of meshes and ``push'' and ``pop'' operations in `MeshTree[]`. Normally, each mesh's parent is the previous mesh in series.
But such meshes can be ``remembered'' by adding them to a stack of meshes with a ``push'' operation. This remembered mesh can then be used as the parent mesh
with a ``pop'' operation. It is not clear what the maximum stack depth is; most TR mesh stacks do not extend beyond 2 or 3 meshes.

The animations for each mesh object are selected with some ingenious techniques. Which animations to use are not hardcoded; instead, each entity has some states
it can be in, and these states are used to select which animation. For example, locks have only one state (they just sit there), doors have two states (open and
closed), and Lara has numerous states, such as standing, walking, running, jumping, falling, being hurt, dying, etc. Each animation has a state ID, which can be
used to select it; however, state transitions might seem to require a large number of intermediate states (opening, closing, starting to jump, landing, etc.).
The alternative used in the Tomb Raider engine is for each animation to have bridge animations to other states' animations, which are selected using the ID of
which state to change to. These bridge animations then lead to the animation with the appropriate state. Thus, a closed door will run a looped closed-door
animation as long as its state stays ``closed'', but when its state becomes ``open'', it will change to an opening-door bridge animation, which will end in a
looped open-door animation. Likewise, closing a door will make it use a closing-door bridge animation. Some bridge animations are chosen with a finer grain of
selectivity, however, such as using one for left foot forward and one for right foot forward.

Thus, each animation references a set of `StateChange` structures (called simply a ``structure'' in some documentation), each one of which references an
`AnimDispatch` structure (called a ``range'' in some documentation). Each `StateChange` structure contains a new state and which `AnimDispatch` structures to use.
When an entity goes into a new state, the `StateChange` structures are scanned for that state's ID, and if one matches, then that `StateChange`'s `AnimDispatch` es are
then scanned for a range of frames that contains the ID of the current frame. If such an `AnimDispatch` is found, the animation and the frame are changed to those
listed in it.

The ultimate unit of animation is, of course, the frame, and each frame consists of a bounding box, the offset of the root mesh, and rotation angles for all the
meshes with respect to their parent meshes. The root mesh is also rotated, but relative to the object's overall coordinates. All rotations are performed around
the meshes' origins, and are in order Y, X, Z (yaw, pitch, roll). The reason for the root mesh's displacement is because entities traveling on solid surfaces
are likely tracked by having their locations be at ground level, and Lara's hips, for example, are well above the ground. Finally, some of the angles are not
specified explicitly, when they are not, they are zero.

Frames are referenced in two ways, either by an offset into the `Frames[]` array that contains them, or by frame index. The values of the latter appear to be
unique to each kind of entity, but not between entities; the first frame for each kind is numbered 0. This is likely a convenience when constructing the
animations, since the list of animation frames for each entity can be constructed separately. However, using these indices is fairly simple. Each Animation
structure has a first-frame index; this index is subtracted from the index of the desired frame in order to find out its index relative to the animation's first
frame.

There are also some special AnimCommands (called ``Bone1'' in some documentation) for doing various additional things. Some of them are for setting reference
points; these may either be 3D ones, for example for grab locations, or 2D ones, for jumps from surface. Some others define actions per frame, like playing
sounds, emitting bubbles, and so forth.

Finally, some entities appear to have very incomplete animations; their complete animations are ``borrowed'' from similar entities. One example of this is the
various goons in TR2's Venice levels -- some of them have a full set of animations, while some others have only the standing animation. The ones with only the
standing animation borrow their other animations from the fully-animated ones.

Data Structures
~~~~~~~~~~~~~~~

[source,cpp]
----
/*
 * MeshTree structure
 *
 * MeshTree[] is actually groups of four uint32_t's. The first one is a
 * ``flags'' word;
 *    bit 1 (0x0002) indicates ``put the parent mesh on the mesh stack'';
 *    bit 0 (0x0001) indicates ``take the top mesh off of the mesh stack and use as the parent mesh''
 * when set, otherwise ``use the previous mesh are the parent mesh''.
 * When both are present, the bit-0 operation is always done before the bit-1 operation; in effect, read the stack but do not change it.
 * The next three uint32_t's are X, Y, Z offsets of the mesh's origin from the parent mesh's origin.
 */
struct tr2_meshtree
{
    // 4 bytes
    int32_t Coord;
};
---- 

[source,cpp]
----
/*
 * Animation structure.
 * This describes each individual animation; these may be looped by specifying
 * the next animation to be itself. In TR2 and TR3, one must be careful when
 * parsing frames using the FrameSize value as the size of each frame, since
 * an animation's frame range may extend into the next animation's frame range,
 * and that may have a different FrameSize value.
 */
struct tr2_animation
{
    // 32 bytes
    uint32_t FrameOffset; // byte offset into Frames[] (divide by 2 for Frames[i])
    uint8_t FrameRate;    // Engine ticks per frame
    uint8_t FrameSize; // number of int16_t's in Frames[] used by this animation
    uint16_t StateID;
    uint8_t Unknown2[8];
    uint16_t FrameStart; // first frame in this animation
    uint16_t FrameEnd; // last frame in this animation (numframes = (End - Start) + 1)
    uint16_t NextAnimation;
    uint16_t NextFrame;
    uint16_t NumStateChanges;
    uint16_t StateChangeOffset; // offset into StateChanges[]
    uint16_t NumAnimCommands; // How many of them to use.
    uint16_t AnimCommand; // offset into AnimCommand[]
};
----

[source,cpp]
----
/*
 * State Change structure
 * Each one contains the state to change to and which animation dispatches
 * to use; there may be more than one, with each separate one covering a different
 * range of frames.
 */
struct tr2_state_change
{
    // 6 bytes
    uint16_t StateID;
    uint16_t NumAnimDispatches; // number of ranges (seems to always be 1..5)
    uint16_t AnimDispatch; // Offset into AnimDispatches[]
};
----

[source,cpp]
----
/*
 * Animation Dispatch structure
 * This specifies the next animation and frame to use; these are associated
 * with some range of frames. This makes possible such specificity as one
 * animation for left foot forward and another animation for right foot forward.
 */
struct tr2_anim_dispatch
{
    // 8 bytes
    int16_t Low;                        // Lowest frame that uses this range
    int16_t High;                       // Highest frame (+1?) that uses this range
    int16_t NextAnimation;      // Animation to dispatch to
    int16_t NextFrame;            // Frame offset to dispatch to
};
----

[source,cpp]
----
/*
 * AnimCommand structure
 * These are various commands associated with each animation; they are
 * called ``Bone1'' in some documentation. They are varying numbers of int16_t's
 * packed into an array; the first of each set is the opcode, which determines
 * how operand int16_t's follow it. Some of them refer to the whole animation
 * (jump and grab points, etc.), while others of them are associated with
 * specific frames (sound, bubbles, etc.).
 */
struct tr2_anim_command
{
    // 2 bytes
    int16_t Value;
};
----

Here are all the `AnimCommand` opcodes and their operands.

* 1 -- 3 operands. Position reference: (x,y,z); found in grab and block-move animations
* 2 -- 2 operands. Position reference on surface for jumping: (x,z) for horizontal and (y,z) for vertical surfaces(?)
* 3 -- No operands. Not clear; occurs in animations that are ``slaved'' to other animations, such as Lara throwing switches or moving blocks.
* 4 -- No operands. Not clear; occurs in some death and settling-down animations, but not all.
* 5 -- 2 operands. The first one is a frame number, and the second one is the ID of the sound to play at that frame (internal sound index).

In TR2 and TR3, one of the sound indices two highest bits may be set; when they are, their meanings are:

* `0x4000` -- play this sound when on dry land (example: footsteps)
* `0x8000` -- play this sound when in water (example: running through shallow water)

* 6 -- 2 operands. The first one is a frame number, and the second one is some miscellaneous action.
** 0 -- Occurs in flipping-over animations; freeze camera at current position until end of animation?
** 3 -- Make bubble
** 12 -- Temporarily stop responding to controls?
** etc.
* 14 and 15 -- Some kind of camera control?
* 18 -- ?  +
* 19 -- ?
* 20 -- Lara changing clothes (using a different Lara model)
* 21 -- ?
* 22 -- ?
* 23 -- Hide object
* 24 -- Show object
* 26 -- Some kind of camera control?

TR3 has additional ones, such as

* -32736 = 0x8000 + 32
* 32
* 16416 = 0x4000 + 32

[source,cpp]
----
/*
 * Frame structure.
 *
 * Frames indicate how composite meshes are positioned and rotated. They work
 * in conjunction with Animations[] and MeshTree[]. A given frame has the following
 * format:
 * int16_t BB1x, BB1y, BB1z // bounding box (low)
 * int16_t BB2x, BB2y, BB2z // bounding box (high)
 * int16_t OffsetX, OffsetY, OffsetZ // starting offset for this moveable
 * (TR1 ONLY: int16_t NumValues // number of angle sets to follow; these start with the first mesh, and meshes without angles get zero angles.)
 * (TR2/3: NumValues is implicitly NumMeshes (from moveable))
 * What follows next is a list of angle sets. In TR2/3, an angle set can
 * specify either one or three axes of rotation. If either of the high two
 * bits (0xc000) of the first angle uint16_t are set, it's one axis: only one
 * uint16_t, low 10 bits (0x03ff), scale is 0x100 ::= 90 degrees; the high two
 * bits are interpreted as follows: 0x4000 ::= X only, 0x8000 ::= Y only,
 * 0xC000 ::= Z only.
 * If neither of the high bits are set, it's a three-axis rotation. The next
 * 10 bits (0x3ff0) are the X rotation, the next 10 (including the following
 * uint16_t) (0x000f, 0xfc00) are the Y rotation, the next 10 (0x03ff) are the
 * Z rotation, same scale as before (0x100 ::= 90 degrees).
 * Rotations are performed in Y, X, Z order.
 * TR1 ONLY: All angle sets are two words and interpreted like the two-word
 * sets in TR2/3, EXCEPT that the word order is reversed.
 */
----


[[non-player-character-behaviour]]
Non-Player Character Behaviour
------------------------------

Overview
~~~~~~~~

All the Tomb Raider game physics and entity behavior appears to be hardcoded, with each type ID being associated with some specific sort of behavior (as Lara,
as a boat, as a tiger, as a door, as a boulder, as a lock, etc.). There is no sign of the sorts of schemes used by some other game engines for specifying this
behavior in data files. One scheme is to use generic characters, generic projectiles, and so forth, and to specialize them by reading in appropriate records
from data files. Another scheme is to use interpreted pseudocode; this is used by id's Quake. This hardcoding makes it difficult to port the earlier Tomb Raider
scenarios to the engines of the later games, which could be desirable with their improved 3D-card and sound-card support. While textures, models, and animations
can be ported, behavior cannot be.

However, there is a hint that TR3 may have some such information. Some of its characters are hostile in some levels, and not in others (the India-level monkeys,
the Antarctica-level flamethrower wielders); there may be some flag in `Items[]` that determines whether a character is hostile or not. But the hostile and
non-hostile versions of these characters may have separate type IDs.

Despite that lack, the Tomb Raider series does have navigation hints for the Non-Player Characters; those entities that move freely across the maps under the
command of the game AI. One of the NPCs is the camera, since only Lara (and the vehicles she rides) is under the direct control of the player; the game AI
makes the camera follow Lara. The camera uses the navigation hints used by the flying NPC's; these can be constructed so as to help the camera out of tight
spots.

The navigation hints are three data structures: boxes, overlaps, and zones. Most sectors point to some box, the main exceptions being horizontal-portal sectors.
Several neighbring sectors may point to the same box. A box is a horizontal rectangle, with corners and height specified; each box also has a pointer into the
list of overlaps. Each segment in that list is the list of accessible neighboring boxes for some box; the NPCs apparently select from this list to decide where
to go next. This selection is done with the help of the zones. These structures of [red]#6 (TR1)# or 10 (TR2, TR3) `int16_t`'s that act as zone IDs;
their overall indexing is the same as the boxes, meaning that each box will have an associated set of zone IDs. An NPC will select one of this set to use, and
will prefer to go into the overlaps-list boxes that have the same zone value as the box it is currently in. For example, one can create guard paths by making
chains of zone-ID-sharing boxes, with their overlaps pointing to the next boxes in those chains.

Data Structures
~~~~~~~~~~~~~~~

[[Boxes]]
Boxes
^^^^^

[source,cpp]
----
struct tr2_box
{ 
    // 8 bytes [TR1: 20 bytes] In TR1, the first four are int32_t's instead of uint8_t's, and are not scaled.
    uint8_t Zmin;     // sectors (* 1024 units)
    uint8_t Zmax;
    uint8_t Xmin;
    uint8_t Xmax;
    int16_t TrueFloor; // Y value (no scaling)
    int16_t OverlapIndex; // index into Overlaps[]. The high bit is sometimes set; this
                        // occurs in front of swinging doors and the like.
};
----

Overlaps
^^^^^^^^

This is a set of lists of neighboring boxes for each box, each member being a `uint16_t`; the highest bit being set marks the end of each list. NPCs apparently use
this list to decide where to go next.

Zones
^^^^^

This is a set of `int16_t`'s, [red]#6 for TR1# and 10 for TR2 and TR3. NPCs prefer to travel to a box with the same zone ID as the one they are currently at. Which of
these zone IDs it uses depends on the kind of the NPC and its current state. The first half of the Zones structure is for the ``normal'' room state, and the
second half is for the ``alternate'' room state. TR1, for example, has 2 sets of ground zones and 1 set of fly zones; its zones are

1. ground zone 1 (normal)
2. ground zone 2 (normal)
3. fly zone (normal)
4. ground zone 1 (alternate)
5. ground zone 2 (alternate)
6. fly zone (alternate)

The ground zones are for NPCs that travel on the ground, while the fly zones are for flying or swimming NPCs. TR2 and TR3 have similar breakdowns, though they
have 4 ground zones.
 

Sound
-----

Overview
~~~~~~~~

The Tomb Raider series makes abundant use of sound, which appears in a variety of contexts. Sounds can be either continuous or triggered. Continuous ones can be
for the whole level or produced by some sound-source object. The whole-level sound is a CD-track sound, which is played continuously, thus the blowing-wind
sounds in the underground parts of ``The Great Wall''. Sound-source objects make sound in a range around some specific point. Likewise, triggered ones can be
triggered by a variety of events. The triggering can be hardcoded in the engine (gunshots, switch pulls) or by reaching some animation frame (footsteps, Lara's
somewhat unladylike sounds). Switch pulls and/or door sounds may be specified with operand of `FDFunction 0x09`; operand values lower than those used for
assault-course clock control may specify which sounds to use.

Though CD-track sounds are referred to by track index, game-data sounds are referred to by an internal sound index; this is translated into which sound sample
with the help of three layers of indexing, to allow for a suitable degree of abstraction. Internal sound indices for various sounds appear to be consistent
across all the level files in a game; a gunshot or a passport opening in one level file will have the same internal sound index as in all the others. The
highest level of these is the `SoundMap[]` array, which translates the internal sound index into an index into `SoundDetails[]`. Each `SoundDetails` record contains
such details as the sound intensity, how many samples to select from, and an index into `SampleIndices[]`. This allows for selecting among multiple samples to
produce variety; that index is the index to the `SampleIndices[]` value of first of these, with the rest of them being having the next indices in series of that
array. Thus, if the number of samples is 4, then the TR engine looks in `SampleIndices[]` locations _Index_, _Index+1_, _Index+2_, and _Index+3_. Finally, the
`SampleIndices[]` array references some arrays of sound samples. In TR1, these samples are embedded in the level files, and `SampleIndices[]` contains the
displacements of each one in bytes from the beginning of that embedded block. In TR2 and TR3, these samples are concatenated in the file `MAIN.SFX` with no
additional information; `SampleIndices[]` contains sequence numbers (0, 1, 2, 3, ...) in `MAIN.SFX`. Finally, the samples themselves are all in Microsoft WAVE
format.

The CD-audio tracks are stored in different fashions in the various versions of the TR series.
[green]#In the PC version of TR3, they are all stored in the file
`CDAUDIO.WAD`, which has the format (source: Sven, BachmannS@gmx.net, http://wotsit.org/cgi-bin/download.cgi?tr3audio): a series of header records with this
format:#

[source,cpp]
----
{
    // 0x108 bytes
    int32_t SampleLength;     // how many bytes
    int32_t SampleOffset;     // offset in file
    int8_t Name[256];         // C string; the length is a guess, because Sven's sizes are inconsistent.
};
----
[green]#followed by embedded samples in the Microsoft WAVE format.#

In the Macintosh versions of TR1 and TR2, the CD audio tracks are separate files in AIFF format, while in the Macintosh version of TR3, these tracks are
separate files in Microsoft WAVE format. The Macintosh version of TR3 contains an additional file, `CDAudio.db`, which contains the names of all the track files
as 32-byte zero-padded C strings with no extra contents.

Data Structures
~~~~~~~~~~~~~~~

[source,cpp]
----
/*
 * SoundSource structure
 * This structure contains the details of continuous-sound sources. Although
 * a SoundSource object has a position, it has no room membership; the sound
 * seems to propagate omnidirectionally for about 10 horizontal-grid sizes
 * without regard for the presence of walls.
 */
struct tr2_sound_source
{
    int32_t x;     // absolute X position of sound source (world coordinates)
    int32_t y;     // absolute Y position of sound source (world coordinates)
    int32_t z;     // absolute Z position of sound source (world coordinates)
    uint16_t SoundID; // internal sound index
    uint16_t Flags; // 0x40, 0x80, or 0xc0
};
----

`SoundMap` is for mapping from internal-sound index to `SoundDetails` index; it is 370 `int16_t` in TR2 and TR3 and [red]#256 `int16_t` in TR1#. A value of `-1` indicates
``none''.

[source,cpp]
----
/*
 * Sound-sample details (SoundDetails)
 */
struct tr2_sound_details
{
    // 8 bytes
    int16_t Sample; // (index into SampleIndices)
    int16_t Volume;
    int16_t Unknown1; // sound range? (distance at which this sound can be heard?)
    int16_t Unknown2; // Bits 8-15: priority?, Bits 2-7: number of sound
                           // samples in this group, Bits 0-1: channel number?
};
----

SampleIndices
~~~~~~~~~~~~~

[red]#In TR1, this is a list of indices into the embedded sound-samples object, which precedes this object in the level file.#
In TR2 and TR3, this is
a list of indices into the file `MAIN.SFX`; the indices are the index numbers of that file's embedded sound samples, rather than the samples' starting
locations. That file itself is a set of concatenated soundfiles with no catalogue info present. In all the TR series, the sound format used is Microsoft WAVE.


Miscellany
----------

[NOTE]
These are various odds and ends that do not fit into the earlier categories.

Version
~~~~~~~

Every level file (`.PHD`, `.TUB`, `.TR2`) begins with a `uint32_t` version number.  This seems to be used by the engine to guarantee
compatibility between various level editor versions and the game engine version.  More generally, it can be used to determine what sort of level is being read. 
Here are the known (observed) values for the version header:

* 0x00000020 -- Tomb Raider 1, Gold, Unfinished Business
* 0x0000002d -- Tomb Raider 2
* 0xFF080038 -- Tomb Raider 3
* 0xFF180038 -- Tomb Raider 3

Palette
~~~~~~~

This consists of 256 <<tr_colour>> structs, one for each palette entry. However, the individual colour values range from 0 to 63; they
must be multiplied by 4 to get the correct values.

This used for all 8-bit colour, such as 8-bit textures.

Object Textures
~~~~~~~~~~~~~~~

[source,cpp]
----
/*
 * Object-texture vertex structure. It specifies a vertex location in textile coordinates.
 * The Xpixel and Ypixel are the actual coordinates of the vertex's pixel.
 * The Xcoordinate and Ycoordinate values depend on where the other vertices
 * are in the object texture. And if the object texture is used to specify
 * a triangle, then the fourth vertex's values will all be zero.
 */
struct tr2_object_texture_vert
{
    // 4 bytes
    uint8_t Xcoordinate; // 1 if Xpixel is the low value, 255 if Xpixel is the high value in the object texture
    uint8_t Xpixel;
    uint8_t Ycoordinate; // 1 if Ypixel is the low value, 255 if Ypixel is the high value in the object texture
    uint8_t Ypixel;
};
----

[[tr2_object_texture]]
[source,cpp]
----
/*
 * Object texture structure.
 * These, thee contents of ObjectTextures[], are used for specifying texture
 * mapping for the world geometry and for mesh objects.
 */
struct tr2_object_texture
{
    // 20 bytes
    uint16_t Attribute;  // 0 means that a texture is all-opaque, and that transparency
                       // information is ignored.
                       // 1 means that transparency information is used. In 8-bit colour,
                       // index 0 is the transparent colour, while in 16-bit colour, the
                       // top bit (0x8000) is the alpha channel (1 = opaque, 0 = transparent).
                       // 2 (only in TR3) means that the opacity (alpha) is equal to the intensity;
                       // the brighter the colour, the more opaque it is. The intensity is probably calculated
                       // as the maximum of the individual color values.
    uint16_t Tile; // index into textile list
    tr2_object_texture_vert Vertices[4]; // the four corners of the texture
};
----

Animated Textures
~~~~~~~~~~~~~~~~~

Animated textures describe sets of object textures that are cycled through to produce texture animations; they are a set of int16_t's with the following format
(not a ``real'' C/C++ structure):

[source,cpp]
----
int16_t NumAnimatedTextures
virtual struct
{
    int16_t NumTextureIDs; // Actually, this is the number of texture ID's - 1.
    int16_t TextureIDs[NumTextureIDs + 1]; // offsets into ObjectTextures[], in animation order.
} AnimatedTextures[NumAnimatedTextures];
----

If a texture belongs to an animated-texture group, it will automatically be animated by the engine.

There are two types of animated textures -- 'classic frames' and 'UVRotate':

* *Classic frames:* These are ordinary animated textures, and the only type displayed prior to TR4. It is simply a list of textures that are cycled through in an endless loop; they are normally used as geographic elements of the levels (e.g. water surface, bubbling lava, Atlantean flesh walls), but practically, Tomb Raider engines are capable of applying animated textures to mesh geometry (this feature is primarily used in custom levels). The speed (interval) of animation is hardcoded, and varies from version to version. While in TR1-2 textures were animated relatively slowly, in TR3 onwards they were sped up.

*UV Rotate:* Beginning from TR4, there is a new scheme for animated textures, called 'UVRotate'. According to its name, it continuously shifts vertical texture coordinate while preserving texture size, which creates an effect of moving texture. For example, you can see it in action in TR4's `angkor1.tr4`, room #76.

UVRotate mode is engaged by specifying `UVRotate` command in level script entry, which takes rotation speed as an argument. If such command is found (and argument is not zero -- for example, `UVRotate = 4`), engine uses special variable value kept in level file, `animated_textures_uv_count`, to determine if animation range belongs to UVRotate mode or classic frames mode. Then, if it belongs to UVRotate mode, each frame of this range is treated as individual rotating texture.

[NOTE]
====
There is also special case when UVRotate texture mode is engaged. When a texture is applied to a model with specific ID (so-called 'waterfall objects'), then it is also considered UVRotate animated texture, even if it doesn't belong to animated texture range, 'but only if it is a texture applied to a first face in the first mesh of the model'. If there are other textures applied to other faces of a waterfall object, they won't be considered as UVRotate.

The speed of animation for waterfall objects is not affected by `UVRotate` script command. Instead, it is hardcoded value of 7.
====

Cameras
~~~~~~~

These are positions to switch the camera to; the camera gets switched to one of these as specified in the floordata, which also specify what to look at, how
long to switch, and whether to do so only once.

[source,cpp]
----
struct tr2_camera
{
    int32_t x;
    int32_t y;
    int32_t z;
    int16_t Room;
    uint16_t Unknown1; // correlates to Boxes[]? Zones[]?
};
----
 
Flyby Cameras
~~~~~~~~~~~~~


 

Cinematic Frames
~~~~~~~~~~~~~~~~

These are camera positionings for cutscenes. All the entity animations are specified separately, and it is not clear where there is any syncing between these
frames and any of the animations.

[source,cpp]
----
struct tr2_cinematic_frame
{
    int16_t rotY;   // rotation about Y axis, +/- 32767 == +/- 180 degrees
    int16_t rotZ;   // rotation about Z axis, +/- 32767 == +/- 180 degrees
    int16_t rotZ2;  // seems to work a lot like rotZ;  I haven't yet been able to
                  // differentiate them
    int16_t posZ;   // camera position relative to something (target? Lara? room
                  // origin?).  pos* are _not_ in world coordinates.
    int16_t posY;   // camera position relative to something (see posZ)
    int16_t posX;   // camera position relative to something (see posZ)
    int16_t unknown; // changing this can cause a runtime error
    int16_t rotX;   // rotation about X axis, +/- 32767 == +/- 180 degrees
};
----
 

LightMap
~~~~~~~~

A 32*256 array of `uint8_t` which is apparently for applying light to 8-bit colour, in some documentation called `ColourMap`. The current
palette index and lighting value are used to calcuate an index to this table, which is a table of palette indices.

The Tomb Raider series' software rendering, like that of most real-time-3D games, uses 8-bit colour for speed and low bulk; however, there is the serious
problem of how to do lighting with 8-bit colour, because doing it directly is computationally expensive. The usual solution is to arrange the palettes' colours
in ramps, which the engine then follows in the appropriate directions. However, the TR series' palettes generally lack such neat ramps.

But the TR series has a more general solution, one that does not require palettes to have colour ramps. It uses precalculated lighting tables, the `ColourMap`
objects. These contain translations of a colour value and a lighting value, listed by palette index. The translation goes as follows:

`n = ColourMap[256 * k + i];`

where `i` is the original palette index, `k` is determined from the lighting value, and `n` is the new palette index. The lighting index `k` varies from 0 to 31, and
the corresponding lighting value is, [red]#for TR1#,

`2 - k / 16`

and for TR2 and TR3,

`2 - (k + 1) / 16`

This may be associated with the curious fact of the lighting values in the data files increasing in the ``wrong'' direction in TR1 and TR2, with 0 being full
brightness and greater values being darker.
 

Level File Formats
------------------

The Entire TR1 Level Format
~~~~~~~~~~~~~~~~~~~~~~~~~~~

What follows is the physical `.PHD` file layout, byte for byte.

[CAUTION]
This is not a ``real'' C/C++ structure, in that some arrays are variable-length, with the length being defined by another element of the structure.

[source,cpp]
----
uint32_t Version; // version (4 bytes)
uint32_t NumTextiles; // number of texture tiles (4 bytes)
tr2_textile8 Textile8[NumTextiles]; // 8-bit (palettized) textiles (NumTextiles * 65536 bytes)
uint32_t Unused; // 32-bit unused value (4 bytes)
uint16_t NumRooms; // number of rooms (2 bytes)
virtual struct
{
    tr2_room_info RoomInfo; // room header (16 bytes)
    uint32_t NumData; // number of data uint16_t's to follow (=RoomData) (4 bytes)
    virtual struct
    {
        uint16_t NumVertices; // number of vertices to follow (2 bytes)
        tr2_vertex_room Vertices[NumVertices]; // vertex list (NumVertices * 8 bytes [TR1 version])
        uint16_t NumRectangles; // number of rectangles to follow (2 bytes)
        tr_face4 Rectangles[NumRectangles]; // rectangle list (NumRectangles * 10 bytes)
        uint16_t NumTriangles; // number of triangles to follow (2 bytes)
        tr_face3 Triangles[NumTriangles]; // triangle list (NumTriangles * 8 bytes)
        uint16_t NumSprites; // number of sprites to follow (2 bytes)
        tr2_room_sprite Sprites[NumSprites]; // room sprite list (NumSprites * 4 bytes)
        uint16_t NumDoors; // number of doors to follow (2 bytes)
        tr2_room_door Doors[NumDoors]; // door list (NumDoors * 32 bytes)
        uint16_t NumZsector; // sector table width (2 bytes)
        uint16_t NumXsector; // sector table height (2 bytes)
        tr2_room_sector SectorData[NumZsector * NumXsector]; // sector table (NumZsector * NumXsector * 8 bytes)
        int16_t Intensity1;
        uint16_t NumLights; // number of lights to follow (2 bytes)
        tr2_room_light Lights[NumLights]; // light list (NumLights * 18 bytes [TR1 version])
        uint16_t NumStaticMeshes; // number of static mesh records to follow (2 bytes)
        tr2_room_staticmesh StaticMeshes[NumStaticMeshes]; // static mesh data (NumStaticMeshes * 18 bytes [TR1 version])
        int16_t AlternateRoom; // (2 bytes)
        uint16_t Flags; // (2 bytes)
    } RoomData;
} Rooms[NumRooms];
uint32_t NumFloorData; // number of floor data uint16_t's to follow (4 bytes)
uint16_t FloorData[NumFloorData]; // floor data (NumFloorData * 2 bytes)
uint32_t NumMeshData; // number of uint16_t's of mesh data to follow (=Meshes[]) (4 bytes)
virtual struct
{
    tr2_vertex Centre; // relative coordinates of mesh centre (6 bytes)
    uint8_t Unknown1[4]; // unknown (4 bytes)
    int16_t NumVertices; // number of vertices to follow (2 bytes)
    tr2_vertex Vertices[NumVertices]; // list of vertices (NumVertices * 6 bytes)
    int16_t NumNormals; // number of normals to follow (2 bytes)
    tr2_vertex Normals[NumNormals]; // list of normals (NumNormals * 6 bytes) (becomes Lights if NumNormals < 0; 2 bytes)
    int16_t NumTexturedRectangles; // number of textured rectangles to follow (2 bytes)
    tr_face4 TexturedRectangles[NumTexturedRectangles]; // list of textured rectangles (NumTexturedRectangles * 10 bytes)
    int16_t NumTexturedTriangles; // number of textured triangles to follow (2 bytes)
    tr_face3 TexturedTriangles[NumTexturedTriangles]; // list of textured triangles (NumTexturedTriangles * 8 bytes)
    int16_t NumColouredRectangles; // number of coloured rectangles to follow (2 bytes)
    tr_face4 ColouredRectangles[NumColouredRectangles]; // list of coloured rectangles (NumColouredRectangles * 10 bytes)
    int16_t NumColouredTriangles; // number of coloured triangles to follow (2 bytes)
    tr_face3 ColouredTriangles[NumColouredTriangles]; // list of coloured triangles (NumColouredTriangles * 8 bytes)
} Meshes[NumMeshPointers]; // note that NumMeshPointers comes AFTER Meshes[]
uint32_t NumMeshPointers; // number of mesh pointers to follow (4 bytes)
uint32_t MeshPointers[NumMeshPointers]; // mesh pointer list (NumMeshPointers * 4 bytes)
uint32_t NumAnimations; // number of animations to follow (4 bytes)
tr2_animation Animations[NumAnimations]; // animation list (NumAnimations * 32 bytes)
uint32_t NumStateChanges; // number of state changes to follow (4 bytes)
tr2_state_change StateChanges[NumStateChanges]; // state-change list (NumStructures * 6 bytes)
uint32_t NumAnimDispatches; // number of animation dispatches to follow (4 bytes)
tr2_anim_dispatch AnimDispatches[NumAnimDispatches]; // animation-dispatch list list (NumAnimDispatches * 8 bytes)
uint32_t NumAnimCommands; // number of animation commands to follow (4 bytes)
tr2_anim_command AnimCommands[NumAnimCommands]; // animation-command list (NumAnimCommands * 2 bytes)
uint32_t NumMeshTrees; // number of MeshTrees to follow (4 bytes)
tr2_meshtree MeshTrees[NumMeshTrees]; // MeshTree list (NumMeshTrees * 4 bytes)
uint32_t NumFrames; // number of words of frame data to follow (4 bytes)
uint16_t Frames[NumFrames]; // frame data (NumFrames * 2 bytes)
uint32_t NumMoveables; // number of moveables to follow (4 bytes)
tr2_moveable Moveables[NumMoveables]; // moveable list (NumMoveables * 18 bytes)
uint32_t NumStaticMeshes; // number of StaticMesh data records to follow (4 bytes)
tr2_staticmesh StaticMeshes[NumStaticMeshes]; // StaticMesh data (NumStaticMesh * 32 bytes)
uint32_t NumObjectTextures; // number of object textures to follow (4 bytes) (after AnimatedTextures in TR3)
tr2_object_texture ObjectTextures[NumObjectTextures]; // object texture list (NumObjectTextures * 20 bytes) (after AnimatedTextures in TR3)
uint32_t NumSpriteTextures; // number of sprite textures to follow (4 bytes)
tr2_sprite_texture SpriteTextures[NumSpriteTextures]; // sprite texture list (NumSpriteTextures * 16 bytes)
uint32_t NumSpriteSequences; // number of sprite sequences records to follow (4 bytes)
tr2_sprite_sequence SpriteSequences[NumSpriteSequences]; // sprite sequence data (NumSpriteSequences * 8 bytes)
uint32_t NumCameras; // number of camera data records to follow (4 bytes)
tr2_camera Cameras[NumCameras]; // camera data (NumCameras * 16 bytes)
uint32_t NumSoundSources; // number of sound source data records to follow (4 bytes)
tr2_sound_source SoundSources[NumSoundSources]; // sound source data (NumSoundSources * 16 bytes)
uint32_t NumBoxes; // number of box data records to follow (4 bytes)
tr2_box Boxes[NumBoxes]; // box data (NumBoxes * 20 bytes [TR1 version])
uint32_t NumOverlaps; // number of overlap records to follow (4 bytes)
uint16_t Overlaps[NumOverlaps]; // overlap data (NumOverlaps * 2 bytes)
int16_t Zones[6*NumBoxes]; // zone data (NumBoxes * 12 bytes [TR1 version])
uint32_t NumAnimatedTextures; // number of animated texture records to follow (4 bytes)
uint16_t AnimatedTextures[NumAnimatedTextures]; // animated texture data (NumAnimatedTextures * 2 bytes)
uint32_t NumItems; // number of items to follow (4 bytes)
tr2_item Items[NumItems]; // item list (NumItems * 22 bytes [TR1 version])
uint8_t LightMap[32 * 256]; // light map (8192 bytes)
tr_colour Palette[256]; // 8-bit palette (768 bytes)
uint16_t NumCinematicFrames; // number of cinematic frame records to follow (2 bytes)
tr2_cinematic_frame CinematicFrames[NumCinematicFrames]; // (NumCinematicFrames * 16 bytes)
uint16_t NumDemoData; // number of demo data records to follow (2 bytes)
uint8_t DemoData[NumDemoData]; // demo data (NumDemoData bytes)
int16_t SoundMap[256]; // sound map (512 bytes)
uint32_t NumSoundDetails; // number of sound-detail records to follow (4 bytes)
tr2_sample_info SoundDetails[NumSoundDetails]; // sound-detail list (NumSoundDetails * 8 bytes)
uint32_t NumSamples (number of uint8_t's in Samples)
uint8_t Samples (array of uint8_t's -- embedded sound samples in Microsoft WAVE format)
uint32_t NumSampleIndices; // number of sample indices to follow (4 bytes)
uint32_t SampleIndices[NumSampleIndices]; // sample indices (NumSampleIndices * 4 bytes)
----

The Entire TR2 Level Format
~~~~~~~~~~~~~~~~~~~~~~~~~~~

What follows is the physical `.TR2` file layout, byte for byte.

[CAUTION]
This is not a ``real'' C/C++ structure, in that some arrays are variable-length, with the length being defined by another element of the structure.

[source,cpp]
----
uint32_t Version; // version (4 bytes)
tr_colour Palette[256]; // 8-bit palette (768 bytes)
tr_colour4 Palette16[256]; //  (1024 bytes)
uint32_t NumTextiles; // number of texture tiles (4 bytes)
tr2_textile8 Textile8[NumTextiles]; // 8-bit (palettized) textiles (NumTextiles * 65536 bytes)
tr2_textile16 Textile16[NumTextiles]; // 16-bit (ARGB) textiles (NumTextiles * 131072 bytes)
uint32_t Unused; // 32-bit unused value (4 bytes)
uint16_t NumRooms; // number of rooms (2 bytes)
virtual struct
{
    tr2_room_info RoomInfo; // room header (16 bytes)
    uint32_t NumData; // number of data uint16_t's to follow (=RoomData) (4 bytes)
    virtual struct
    {
        uint16_t NumVertices; // number of vertices to follow (2 bytes)
        tr2_vertex_room Vertices[NumVertices]; // vertex list (NumVertices * 12 bytes)
        uint16_t NumRectangles; // number of rectangles to follow (2 bytes)
        tr_face4 Rectangles[NumRectangles]; // rectangle list (NumRectangles * 10 bytes)
        uint16_t NumTriangles; // number of triangles to follow (2 bytes)
        tr_face3 Triangles[NumTriangles]; // triangle list (NumTriangles * 8 bytes)
        uint16_t NumSprites; // number of sprites to follow (2 bytes)
        tr2_room_sprite Sprites[NumSprites]; // room sprite list (NumSprites * 4 bytes)
        uint16_t NumDoors; // number of doors to follow (2 bytes)
        tr2_room_door Doors[NumDoors]; // door list (NumDoors * 32 bytes)
        uint16_t NumZsector; // sector table width (2 bytes)
        uint16_t NumXsector; // sector table height (2 bytes)
        tr2_room_sector SectorData[NumZsector * NumXsector]; // sector table (NumZsector * NumXsector * 8 bytes)
        int16_t Intensity1;
        int16_t Intensity2;
        int16_t LightMode;
        uint16_t NumLights; // number of lights to follow (2 bytes)
        tr2_room_light Lights[NumLights]; // light list (NumLights * 24 bytes)
        uint16_t NumStaticMeshes; // number of static mesh records to follow (2 bytes)
        tr2_room_staticmesh StaticMeshes[NumStaticMeshes]; // static mesh data (NumStaticMeshes * 20 bytes)
        int16_t AlternateRoom; // (2 bytes)
        uint16_t Flags; // (2 bytes)
    } RoomData;
} Rooms[NumRooms];
uint32_t NumFloorData; // number of floor data uint16_t's to follow (4 bytes)
uint16_t FloorData[NumFloorData]; // floor data (NumFloorData * 2 bytes)
uint32_t NumMeshData; // number of uint16_t's of mesh data to follow (=Meshes[]) (4 bytes)
virtual struct
{
    tr2_vertex Centre; // relative coordinates of mesh centre (6 bytes)
    uint8_t Unknown1[4]; // unknown (4 bytes)
    int16_t NumVertices; // number of vertices to follow (2 bytes)
    tr2_vertex Vertices[NumVertices]; // list of vertices (NumVertices * 6 bytes)
    int16_t NumNormals; // number of normals to follow (2 bytes)
    tr2_vertex Normals[NumNormals]; // list of normals (NumNormals * 6 bytes) (becomes Lights if NumNormals < 0; 2 bytes)
    int16_t NumTexturedRectangles; // number of textured rectangles to follow (2 bytes)
    tr_face4 TexturedRectangles[NumTexturedRectangles]; // list of textured rectangles (NumTexturedRectangles * 10 bytes)
    int16_t NumTexturedTriangles; // number of textured triangles to follow (2 bytes)
    tr_face3 TexturedTriangles[NumTexturedTriangles]; // list of textured triangles (NumTexturedTriangles * 8 bytes)
    int16_t NumColouredRectangles; // number of coloured rectangles to follow (2 bytes)
    tr_face4 ColouredRectangles[NumColouredRectangles]; // list of coloured rectangles (NumColouredRectangles * 10 bytes)
    int16_t NumColouredTriangles; // number of coloured triangles to follow (2 bytes)
    tr_face3 ColouredTriangles[NumColouredTriangles]; // list of coloured triangles (NumColouredTriangles * 8 bytes)
} Meshes[NumMeshPointers]; // note that NumMeshPointers comes AFTER Meshes[]
uint32_t NumMeshPointers; // number of mesh pointers to follow (4 bytes)
uint32_t MeshPointers[NumMeshPointers]; // mesh pointer list (NumMeshPointers * 4 bytes)
uint32_t NumAnimations; // number of animations to follow (4 bytes)
tr2_animation Animations[NumAnimations]; // animation list (NumAnimations * 32 bytes)
uint32_t NumStateChanges; // number of state changes to follow (4 bytes)
tr2_state_change StateChanges[NumStateChanges]; // state-change list (NumStructures * 6 bytes)
uint32_t NumAnimDispatches; // number of animation dispatches to follow (4 bytes)
tr2_anim_dispatch AnimDispatches[NumAnimDispatches]; // animation-dispatch list list (NumAnimDispatches * 8 bytes)
uint32_t NumAnimCommands; // number of animation commands to follow (4 bytes)
tr2_anim_command AnimCommands[NumAnimCommands]; // animation-command list (NumAnimCommands * 2 bytes)
uint32_t NumMeshTrees; // number of MeshTrees to follow (4 bytes)
tr2_meshtree MeshTrees[NumMeshTrees]; // MeshTree list (NumMeshTrees * 4 bytes)
uint32_t NumFrames; // number of words of frame data to follow (4 bytes)
uint16_t Frames[NumFrames]; // frame data (NumFrames * 2 bytes)
uint32_t NumMoveables; // number of moveables to follow (4 bytes)
tr2_moveable Moveables[NumMoveables]; // moveable list (NumMoveables * 18 bytes)
uint32_t NumStaticMeshes; // number of StaticMesh data records to follow (4 bytes)
tr2_staticmesh StaticMeshes[NumStaticMeshes]; // StaticMesh data (NumStaticMesh * 32 bytes)
uint32_t NumObjectTextures; // number of object textures to follow (4 bytes)
tr2_object_texture ObjectTextures[NumObjectTextures]; // object texture list (NumObjectTextures * 20 bytes) (after
AnimatedTextures in TR3)
uint32_t NumSpriteTextures; // number of sprite textures to follow (4 bytes)
tr2_sprite_texture SpriteTextures[NumSpriteTextures]; // sprite texture list (NumSpriteTextures * 16 bytes)
uint32_t NumSpriteSequences; // number of sprite sequences records to follow (4 bytes)
tr2_sprite_sequence SpriteSequences[NumSpriteSequences]; // sprite sequence data (NumSpriteSequences * 8 bytes)
uint32_t NumCameras; // number of camera data records to follow (4 bytes)
tr2_camera Cameras[NumCameras]; // camera data (NumCameras * 16 bytes)
uint32_t NumSoundSources; // number of sound source data records to follow (4 bytes)
tr2_sound_source SoundSources[NumSoundSources]; // sound source data (NumSoundSources * 16 bytes)
uint32_t NumBoxes; // number of box data records to follow (4 bytes)
tr2_box Boxes[NumBoxes]; // box data (NumBoxes * 8 bytes)
uint32_t NumOverlaps; // number of overlap records to follow (4 bytes)
uint16_t Overlaps[NumOverlaps]; // overlap data (NumOverlaps * 2 bytes)
int16_t Zones[10*NumBoxes]; // zone data (NumBoxes * 20 bytes)
uint32_t NumAnimatedTextures; // number of animated texture records to follow (4 bytes)
uint16_t AnimatedTextures[NumAnimatedTextures]; // animated texture data (NumAnimatedTextures * 2 bytes)
uint32_t NumItems; // number of items to follow (4 bytes)
tr2_item Items[NumItems]; // item list (NumItems * 24 bytes)
uint8_t LightMap[32 * 256]; // light map (8192 bytes)
uint16_t NumCinematicFrames; // number of cinematic frame records to follow (2 bytes)
tr2_cinematic_frame CinematicFrames[NumCinematicFrames]; // (NumCinematicFrames * 16 bytes)
uint16_t NumDemoData; // number of demo data records to follow (2 bytes)
uint8_t DemoData[NumDemoData]; // demo data (NumDemoData bytes)
int16_t SoundMap[370]; // sound map (740 bytes)
uint32_t NumSoundDetails; // number of sound-detail records to follow (4 bytes)
tr2_sample_info SoundDetails[NumSoundDetails]; // sound-detail list (NumSoundDetails * 8 bytes)
uint32_t NumSampleIndices; // number of sample indices to follow (4 bytes)
uint32_t SampleIndices[NumSampleIndices]; // sample indices (NumSampleIndices * 4 bytes)
----

The Entire TR3 Level Format
~~~~~~~~~~~~~~~~~~~~~~~~~~~

What follows is the physical Tomb Raider III `.TR2` file layout, byte for byte.

[CAUTION]
This is not a ``real'' C/C++ structure, in that some arrays are variable-length, with the length being defined by another element of the structure.

[source,cpp]
----
uint32_t Version; // version (4 bytes)
tr_colour Palette[256]; // 8-bit palette (768 bytes)
tr_colour4 Palette16[256]; //  (1024 bytes)
uint32_t NumTextiles; // number of texture tiles (4 bytes)
tr2_textile8 Textile8[NumTextiles]; // 8-bit (palettized) textiles (NumTextiles * 65536 bytes)
tr2_textile16 Textile16[NumTextiles]; // 16-bit (ARGB) textiles (NumTextiles * 131072 bytes) (absent from TR1)
uint32_t Unused; // 32-bit unused value (4 bytes)
uint16_t NumRooms; // number of rooms (2 bytes)
virtual struct
{
    tr2_room_info RoomInfo; // room header (16 bytes)
    uint32_t NumData; // number of data uint16_t's to follow (=RoomData) (4 bytes)
    virtual struct
    {
        uint16_t NumVertices; // number of vertices to follow (2 bytes)
        tr2_vertex_room Vertices[NumVertices]; // vertex list (NumVertices * 12 bytes)
        uint16_t NumRectangles; // number of rectangles to follow (2 bytes)
        tr_face4 Rectangles[NumRectangles]; // rectangle list (NumRectangles * 10 bytes)
        uint16_t NumTriangles; // number of triangles to follow (2 bytes)
        tr_face3 Triangles[NumTriangles]; // triangle list (NumTriangles * 8 bytes)
        uint16_t NumSprites; // number of sprites to follow (2 bytes)
        tr2_room_sprite Sprites[NumSprites]; // room sprite list (NumSprites * 4 bytes)
        uint16_t NumDoors; // number of doors to follow (2 bytes)
        tr2_room_door Doors[NumDoors]; // door list (NumDoors * 32 bytes)
        uint16_t NumZsector; // sector table width (2 bytes)
        uint16_t NumXsector; // sector table height (2 bytes)
        tr2_room_sector SectorData[NumZsector * NumXsector]; // sector table (NumZsector * NumXsector * 8 bytes)
        int16_t Intensity1;
        int16_t Intensity2;
        uint16_t NumLights; // number of lights to follow (2 bytes)
        tr2_room_light Lights[NumLights]; // light list (NumLights * 24 bytes)
        uint16_t NumStaticMeshes; // number of static mesh records to follow (2 bytes)
        tr2_room_staticmesh StaticMeshes[NumStaticMeshes]; // static mesh data (NumStaticMeshes * 20 bytes)
        int16_t AlternateRoom; // (2 bytes)
        uint16_t Flags; // (2 bytes)
        tr_colour RoomLightColour // 3 bytes
    } RoomData;
} Rooms[NumRooms];
uint32_t NumFloorData; // number of floor data uint16_t's to follow (4 bytes)
uint16_t FloorData[NumFloorData]; // floor data (NumFloorData * 2 bytes)
uint32_t NumMeshData; // number of uint16_t's of mesh data to follow (=Meshes[]) (4 bytes)
virtual struct
{
    tr2_vertex Centre; // relative coordinates of mesh centre (6 bytes)
    uint8_t Unknown1[4]; // unknown (4 bytes)
    int16_t NumVertices; // number of vertices to follow (2 bytes)
    tr2_vertex Vertices[NumVertices]; // list of vertices (NumVertices * 6 bytes)
    int16_t NumNormals; // number of normals to follow (2 bytes)
    tr2_vertex Normals[NumNormals]; // list of normals (NumNormals * 6 bytes) (becomes Lights if NumNormals < 0; 2 bytes)
    int16_t NumTexturedRectangles; // number of textured rectangles to follow (2 bytes)
    tr_face4 TexturedRectangles[NumTexturedRectangles]; // list of textured rectangles (NumTexturedRectangles * 10 bytes)
    int16_t NumTexturedTriangles; // number of textured triangles to follow (2 bytes)
    tr_face3 TexturedTriangles[NumTexturedTriangles]; // list of textured triangles (NumTexturedTriangles * 8 bytes)
    int16_t NumColouredRectangles; // number of coloured rectangles to follow (2 bytes)
    tr_face4 ColouredRectangles[NumColouredRectangles]; // list of coloured rectangles (NumColouredRectangles * 10 bytes)
    int16_t NumColouredTriangles; // number of coloured triangles to follow (2 bytes)
    tr_face3 ColouredTriangles[NumColouredTriangles]; // list of coloured triangles (NumColouredTriangles * 8 bytes)
} Meshes[NumMeshPointers]; // note that NumMeshPointers comes AFTER Meshes[]
uint32_t NumMeshPointers; // number of mesh pointers to follow (4 bytes)
uint32_t MeshPointers[NumMeshPointers]; // mesh pointer list (NumMeshPointers * 4 bytes)
uint32_t NumAnimations; // number of animations to follow (4 bytes)
tr2_animation Animations[NumAnimations]; // animation list (NumAnimations * 32 bytes)
uint32_t NumStateChanges; // number of state changes to follow (4 bytes)
tr2_state_change StateChanges[NumStateChanges]; // state-change list (NumStructures * 6 bytes)
uint32_t NumAnimDispatches; // number of animation dispatches to follow (4 bytes)
tr2_anim_dispatch AnimDispatches[NumAnimDispatches]; // animation-dispatch list list (NumAnimDispatches * 8 bytes)
uint32_t NumAnimCommands; // number of animation commands to follow (4 bytes)
tr2_anim_command AnimCommands[NumAnimCommands]; // animation-command list (NumAnimCommands * 2 bytes)
uint32_t NumMeshTrees; // number of MeshTrees to follow (4 bytes)
tr2_meshtree MeshTrees[NumMeshTrees]; // MeshTree list (NumMeshTrees * 4 bytes)
uint32_t NumFrames; // number of words of frame data to follow (4 bytes)
uint16_t Frames[NumFrames]; // frame data (NumFrames * 2 bytes)
uint32_t NumMoveables; // number of moveables to follow (4 bytes)
tr2_moveable Moveables[NumMoveables]; // moveable list (NumMoveables * 18 bytes)
uint32_t NumStaticMeshes; // number of StaticMesh data records to follow (4 bytes)
tr2_staticmesh StaticMeshes[NumStaticMeshes]; // StaticMesh data (NumStaticMesh * 32 bytes)
uint32_t NumSpriteTextures; // number of sprite textures to follow (4 bytes)
tr2_sprite_texture SpriteTextures[NumSpriteTextures]; // sprite texture list (NumSpriteTextures * 16 bytes)
uint32_t NumSpriteSequences; // number of sprite sequences records to follow (4 bytes)
tr2_sprite_sequence SpriteSequences[NumSpriteSequences]; // sprite sequence data (NumSpriteSequences * 8 bytes)
uint32_t NumCameras; // number of camera data records to follow (4 bytes)
tr2_camera Cameras[NumCameras]; // camera data (NumCameras * 16 bytes)
uint32_t NumSoundSources; // number of sound source data records to follow (4 bytes)
tr2_sound_source SoundSources[NumSoundSources]; // sound source data (NumSoundSources * 16 bytes)
uint32_t NumBoxes; // number of box data records to follow (4 bytes)
tr2_box Boxes[NumBoxes]; // box data (NumBoxes * 8 bytes)
uint32_t NumOverlaps; // number of overlap records to follow (4 bytes)
uint16_t Overlaps[NumOverlaps]; // overlap data (NumOverlaps * 2 bytes)
int16_t Zones[10*NumBoxes]; // zone data (NumBoxes * 20 bytes)
uint32_t NumAnimatedTextures; // number of animated texture records to follow (4 bytes)
uint16_t AnimatedTextures[NumAnimatedTextures]; // animated texture data (NumAnimatedTextures * 2 bytes)
uint32_t NumObjectTextures; // number of object textures to follow (4 bytes) (after AnimatedTextures in TR3)
tr2_object_texture ObjectTextures[NumObjectTextures]; // object texture list (NumObjectTextures * 20 bytes)
uint32_t NumItems; // number of items to follow (4 bytes)
tr2_item Items[NumItems]; // item list (NumItems * 24 bytes)
uint8_t LightMap[32 * 256]; // light map (8192 bytes)
uint16_t NumCinematicFrames; // number of cinematic frame records to follow (2 bytes)
tr2_cinematic_frame CinematicFrames[NumCinematicFrames]; // (NumCinematicFrames * 16 bytes)
uint16_t NumDemoData; // number of demo data records to follow (2 bytes)
uint8_t DemoData[NumDemoData]; // demo data (NumDemoData bytes)
int16_t SoundMap[370]; // sound map (740 bytes)
uint32_t NumSoundDetails; // number of sound-detail records to follow (4 bytes)
tr2_sample_info SoundDetails[NumSoundDetails]; // sound-detail list (NumSoundDetails * 8 bytes)
uint32_t NumSampleIndices; // number of sample indices to follow (4 bytes)  +
uint32_t SampleIndices[NumSampleIndices]; // sample indices (NumSampleIndices * 4 bytes)
----

The Entire TR4 Level Format
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Entire TR5 Level Format
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Itemized Differences between TR1 and TR2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* TR1 has no colour table or 16-bit palette before the start of the textures; it also lacks 16-bit textures.
* In TR1, tr2_vertex_room_struct has after its tr2_vertex struct only the first light intensity, and not the attributes or the second intensity.
* In TR1, after SectorData, there is only the first light intensity, and not the second one or the lighting mode.
* In TR1, tr2_room_light_struct has only one of:
** uint16_t Diffuse1/2
** uint32_t Unknown1/2
* In TR1, tr2_room_static does not have two light intensities, but only one.
* ``Boxes'' objects are rectangles whose four horizontal-coordinate values are `uint8_t`'s in TR2 and `int32_t`'s in TR1.
* ``Zones'' objects have 10 int16_t's in TR2, but 6 int16_t's in TR1
* In TR1, `tr2_item_struct` is like the TR2 version, but with only one light intensity.
* The TR1 colour table has the same format as the TR2 colour table, but it is located between the LightMap and the cinematic frames.
* SoundMap is 370 `int16_t`'s in TR2, but 256 `int16_t`'s in TR1.
* Between SoundDetails and SampleIndices, TR1 has all the level's sound samples, in the form of embedded Microsoft WAVE files. Just before these samples is the
  total number of bytes in those sound samples, which is a int32_t.

Itemized Differences between TR2 and TR3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* After the two room-light intensities, TR2 has a lighting-mode value, which TR3 lacks.
* Also in `tr2_room_struct`, TR3 has 3 extra bytes at the end, which appears to be the room-light color.
* Finally, in TR2, the `tr2_object_texture` data is before the `tr2_sprite_texture` data. In TR3, it is before the `tr2_item` data.

Itemized Differences between TR3 and TR4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Itemized Differences between TR4 and TR5
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Itemized Differences between ``normal'' TRs and Demos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Presumably as a form of copy protection, the demo versions of some of the TR games use levels that are slightly different from those in the retail versions.
  However, those that have been found are all data rearrangements, as explained below.
* The TR1 and Unfinished Business (`.TUB`) demos have their palettes moved to between the SpriteSequences and the Cameras.
* The TR2 ``Wall'' demo, and maybe also its ``Venice'' demo, has its LightMap (8K) moved to between the SpriteSequences and the Cameras. It also has its
  SampleIndices content replaced by the soundfiles, though the associated number of them remains unchanged (the number of indices becomes the number of samples).
* That demo also has its own version of `TOMBPC.DAT`, called `DEMOPC.DAT`, which appears to have the exact same format as `TOMBPC.DAT`.

No rearrangements are known for the TR3 demos.

Scripting with `TOMBPC.DAT`
---------------------------

Overview
~~~~~~~~

The flow of the game, which levels come in what order, what item(s) Lara has at the beginning of each level, the filenames of the level and cut-scene
files, all the visible text (e.g. ``Save Game,'' ``Rusty Key,'' etc.), and various other options are controlled using a file called `TOMBPC.DAT`. This file is
normally compiled using a utility called `GAMEFLOW.EXE`, which was (apparently) accidentally distributed by Eidos in the German distribution of Tomb Raider II
Gold. TR2 and TR3 use this file, and use essentially the same format of it, but TR1 has this file's contents embedded in the app, which explains why there are
separate TR1 and Unfinished Business apps. What follows is a description of the contents of the binary TOMBPC.DAT file.

[source,cpp]
----
uint32_t Version;                      // seems to be 3 for TR2
uint8_t Info[256];                     // null-terminated string describing this game, copyright info, etc.  NOT ENCRYPTED
int32_t FirstOption;                 // Level to go to when that happens (0x500 is exit-to-title) ??? when WHAT happens?
int32_t TitleReplace;               //  Level to go to when that happens (-1 is NONE) ??? when WHAT happens?
int32_t OnDeathDemoMode; // Level to go to when Lara dies during demo mode (0x500 is exit-to-title)
int32_t OnDeathInGame;        // Level to go to when Lara dies during the game (0 is exit-to-title)
int32_t DemoTime;                 // time in game ticks (1/30th of a second?) to wait before starting a demo
int32_t OnDemoInterrupt;       // Level to go to when demo mode is interrupted (0x500 is exit-to-title)
int32_t OnDemoEnd;              // Level to go to when the demo ends (0x500 is exit-to-title)
uint8_t Unused1[36];               // filler
int16_t NumLevels;                 // number of levels in the game (some level files are used more than once for some reason)
int16_t NumChapterScreens; // chapter screens (Present in TR2, first used in TR3)
int16_t NumTitles;                   // only one, TITLE.TR2
int16_t NumRPLs;                  // number of FMV cutscenes (*.RPL)
int16_t NumCutScenes;         // number of in-game (engine-rendered) cutscenes (CUT*.TR2)
int16_t NumDemoLevels;      // Number of demo levels
int16_t TitleSoundID;             // ID of title soundtrack
int16_t SingleLevel;                // If doing only a single level
uint8_t Unused2[32];              // filler
//
// The Flags word below uses the following bit assignments:
//    0x0001:    DemoVersion                         (1 ::= demo, 0 ::= normal game)
//    0x0002:    Title_Disabled                       (1 ::= no title screen, 0 ::= normal title screen)
//    0x0004:    CheatModeCheck_Disabled  (1 ::= no cheat mode, 0 ::= cheat mode enabled)
//    0x0008:    NoInputTimeout                     (1 ::= wait forever if no input, 0 ::= enter demo
// mode if no input timeout)
//    0x0010:    LoadSave_Disabled              (1 ::= load/save game disabled, 0 ::= load/save
// game enabled)
//    0x0020:    ScreenSizing_Disabled         (1 ::= no screen re-sizing allowed, 0 ::= screen
// re-sizing allowed)
//    0x0040:    LockOutOptionRing              (1 ::= ???, 0 ::= normal option ring)
//    0x0080:    DozyCheat_Enabled             (???)
//    0x0100:    Use_Encryption                     (1 ::= XOR all StringData with XORbyte, 0 ::= leave
// StringData as-is)
//    0x0400:    SelectAnyLevel                      (1 ::= allow player to select any level, 0 ::= no
// level selection)
//
uint16_t Flags;                         // Various flags (see above)
uint8_t Unused3[6];                 // filler
uint8_t XORbyte;                    // For encryption (``cipher code'')
uint8_t Unused4;                     // High byte of a short?
int16_t SecretSoundID;           // ID of ``found a secret'' soundtrack
uint8_t Unused5[4];                 // filler
//
// The sections that follow contain String Arrays.  These are of the following pseudo-structure:
// virtual struct
// {
//     uint16_t StringOffsets[NumStrings];      // offsets (into StringData[]) of each string
//     uint16_t StringDataSize;                 // number of bytes of raw string data to follow
//     uint8_t   StringData[StringDataSize];    // if Flags & 0x0100, this entire array is XORed with
//                                            // XORbyte
// } StringArray;
//
// While it is not correct C/C++, the following are specified as StringArray[NumStrings],
// where _NumStrings_ indicates the number of StringOffsets in the structure.
//
StringArray LevelDisplayNames[NumLevels];
StringArray ChapterScreens[NumChapterScreens];
StringArray TitleFileNames[NumTitles];
StringArray RPLFileNames[NumRPLs];
StringArray LevelFileNames[NumLevels];
StringArray CutSceneFileNames[NumCutScenes];
//
// The LevelScript contains interpreted data (opcodes and operands) that specify
// actions to take for each level (e.g. play cut scene, take away weapons, etc).  The
// details of this data are discussed below, after the structure descriptions.
//
virtual struct
{
    uint16_t LevelScriptOffsets[NumLevels + 1];    // offsets (into LevelScriptData[])
                                                 // of each level's script data
    uint16_t NumLevelScriptData;
    uint8_t   LevelScriptData[NumLevelScriptData];
} LevelScript;
uint16_t DemoLevelList[NumDemoLevels];
//
// GameStrings 1 and 2 are the level-independent strings that are displayed when interacting
// with the game menus (e.g. ``Inventory,'' ``Load Game,'' ``Jump'' (control setup), ``Shotgun''
// (weapon in inventory), etc.)
//
int16_t NumGameStrings1;
StringArray GameStrings1[NumGameStrings1];
StringArray GameStrings2[41];
//
// KeyStrings1..10 are the level-specific printable strings for the various pickups in each level,
// not including level-independent pickups (e.g. Shotgun Shells, Medi Packs).  These pickups
// are all ``active'' at some point, e.g. they are used as keys or are prerequisites for advancing
// through the game.  Examples include ``Rusty Key,'' ``Green Pass Card,'' ``Circuit Breaker,'' "The
// Seraph," ``Talion,'' etc. Each level of TR2 can contain up to 10 pickups.  The following arrays
// are arranged longitudinally, meaning that each array contains all of the Nth-pickup strings for
// each level.  For example, KeyStrings1 contains the printable names for the ``first'' pickup in
// each level, KeyStrings2 contains the names for the ``second'' pickup, etc.  Note that ``first''
// and ``second'' have nothing to do with the order these objects are encountered in the game;
// they are simply indices used by the game engine (Key 1, Key 2, etc.)
//
StringArray KeyStrings1[NumLevels]; // Puzzle 1
StringArray KeyStrings2[NumLevels]; // Puzzle 2
StringArray KeyStrings3[NumLevels]; // Puzzle 3
StringArray KeyStrings4[NumLevels]; // Puzzle 4
StringArray KeyStrings5[NumLevels]; // Pickup 1
StringArray KeyStrings6[NumLevels]; // Pickup 2
StringArray KeyStrings7[NumLevels]; // Key 1
StringArray KeyStrings8[NumLevels]; // Key 2
StringArray KeyStrings9[NumLevels]; // Key 3
StringArray KeyStrings10[NumLevels]; // Key 4
----

LevelScript Description
~~~~~~~~~~~~~~~~~~~~~~~

In LevelScript, Opcodes and Operands are all `uint16_t`.  Note that if a level is a demo level, its level ID will be 1024 higher than a ``normal''
level ID.

.Opcodes
* 3 -- Play FMV (prerendered cutscene): operand is RPL ID
* 4 -- Play (interactive) game level: operand is level's ID
* 5 -- Play engine-rendered cutscene: operand is cutscene ID
* 6 -- Do level-completion display (no operands)
* 7 -- Play demo level: operand is level ID
* 9 -- End of set (no operands)
* 10 -- Play soundtrack: operand is soundtrack ID (it precedes opcodes of associated levels)
* 11 -- (Lara starts out in motorboat? -- TR2, ``Bartoli's Hideout'') (no operands?)
* 12 -- Chapter screen: operand is chapter ID
* 14 -- Lose your weapons (no operands)
* 15 -- End of game (no operands)
* 16 -- Associated with cutscenes; a viewpoint control? (one operand?)
* 17 -- (one operand?)
* 18 -- Give item; operand is item type (see below)
* 19 -- Item-type 12 state to start level in: operand is state number
* 20 -- Number of secrets (overrides engine's hardcoded count of them?): operand is that number
* 21 -- (no operands?)
* 22 -- Lose your ammo and medipacks? (no operands?)

Opcode-18 stuff to give
^^^^^^^^^^^^^^^^^^^^^^^

(repeat means give another)

.After finding all the secrets in a level (Tomb Raider 2)
* 0 -- Pistols
* 1 -- Shotgun
* 2 -- Automatic pistols
* 3 -- Uzis
* 4 -- Harpoon gun
* 5 -- M-16
* 6 -- Grenade launcher
* 7 -- Pistol clip
* 8 -- Shotgun-shell box
* 9 -- Automatic-pistol clip
* 10 -- Uzi clip
* 11 -- Harpoon bundle
* 12 -- M-16 clip
* 13 -- Grenade pack
* 14 -- Flare box
* 15 -- Small medipack
* 16 -- Big medipack
* 17 -- Pickup 1
* 18 -- Pickup 2
* 19 -- Puzzle 1
* 20 -- Puzzle 2
* 21 -- Puzzle 3
* 22 -- Puzzle 4
* 23 -- Key 1
* 24 -- Key 2
* 25 -- Key 3
* 26 -- Key 4

.When a level starts (Tomb Raider 2)
* 1000 -- Pistols
* 1001 -- Shotgun
* 1002 -- Automatic pistols
* 1003 -- Uzis
* 1004 -- Harpoon gun
* 1005 -- M16
* 1006 -- Grenade launcher
* 1007 -- Pistol clip
* 1008 -- Shotgun-shell box
* 1009 -- Automatic-pistol clip
* 1010 -- Uzi clip
* 1011 -- Harpoon bundle
* 1012 -- M16 clip
* 1013 -- Grenade pack
* 1014 -- Flare box
* 1015 -- Small medipack
* 1016 -- Big medipack
* 1017 -- Pickup 1
* 1018 -- Pickup 2
* 1019 -- Puzzle 1
* 1020 -- Puzzle 2
* 1021 -- Puzzle 3
* 1022 -- Puzzle 4
* 1023 -- Key 1
* 1024 -- Key 2
* 1025 -- Key 3
* 1026 -- Key 4

Tomb Raider 2 identifications
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[NOTE]
====
[blue]#TR2 only information here. These lists are virtually colored blue.#
====

.FMV IDs
* 0 -- LOGO (everybody's corporate logos)
* 1 -- ANCIENT (monks vs. dragon)
* 2 -- MODERN (Lara drops in from helicopter)
* 3 -- LANDING (Seaplane lands at rig)
* 4 -- MS (Lara hitchhikes on a minisub)
* 5 -- CRASH (Lara goes to Tibet and has a rough landing there)
* 6 -- JEEP (Lara steals it and outruns Bartoli's goons)
* 7 -- END (Lara escaping the collapsing lair)

.Cutscene IDs
* 0 -- CUT1 (At the end of the Great Wall)
* 1 -- CUT2 (Lara the stowaway)
* 2 -- CUT3 (Bartoli vs. goon)
* 3 -- CUT4 (Bartoli stabs himself)

.Soundtrack IDs
* 0 -- BLANK (no sound)
* 3 -- CUT1 (``at the fancy door'' soundtrack)
* 4 -- CUT2 (``Lara the stowaway'' soundtrack)
* 5 -- CUT3 (``Bartoli vs. goon'' soundtrack)
* 30 -- CUT4 (``Bartoli stabs himself'' soundtrack)
* 31 -- DERELICT (eerie choppy/echo-y synths)
* 32 -- WATER (dripping/pouring water sounds)
* 33 -- WIND (Blowing wind)
* 34 -- HEARTBT (musical embellishment of one)
* 52 -- SHOWER (that infamous shower scene)
* 58 -- MACHINES (in the offshore rig)
* 59 -- FLOATING (wispy synths)

CDAUDIO.WAD soundtrack file (TR3)
---------------------------------

CUTSEQ file format (TR4-TR5)
----------------------------
